{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-core/package.json","includedInParent":true,"mtime":1528724212618},{"name":"../doc","loc":{"line":7,"column":20}},{"name":"../environment","loc":{"line":8,"column":20}},{"name":"../types","loc":{"line":9,"column":27}},{"name":"../util","loc":{"line":10,"column":22}},{"name":"./broadcast_util","loc":{"line":11,"column":32}},{"name":"./operation","loc":{"line":12,"column":26}},{"name":"./ops","loc":{"line":13,"column":36}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.BinaryOps = undefined;\n\nvar _doc = require(\"../doc\");\n\nvar _environment = require(\"../environment\");\n\nvar _types = require(\"../types\");\n\nvar _util = require(\"../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _broadcast_util = require(\"./broadcast_util\");\n\nvar broadcast_util = _interopRequireWildcard(_broadcast_util);\n\nvar _operation = require(\"./operation\");\n\nvar _ops = require(\"./ops\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar BinaryOps = function () {\n    function BinaryOps() {}\n    BinaryOps.add = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'add');\n        util.assertTypesMatch(a, b);\n        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        var der = function (dy) {\n            var derA = function () {\n                var res = dy;\n                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    res = res.sum(reduceAxes);\n                }\n                return res.reshape(a.shape);\n            };\n            var derB = function () {\n                var res = dy;\n                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    res = res.sum(reduceAxes);\n                }\n                return res.reshape(b.shape);\n            };\n            return { a: derA, b: derB };\n        };\n        return _environment.ENV.engine.runKernel(function (backend) {\n            return backend.add(a, b);\n        }, { a: a, b: b }, der);\n    };\n    BinaryOps.addStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');\n        return a.add(b);\n    };\n    BinaryOps.sub = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'sub');\n        util.assertTypesMatch(a, b);\n        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        var der = function (dy) {\n            var derA = function () {\n                var res = dy;\n                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    res = res.sum(reduceAxes);\n                }\n                return res.reshape(a.shape);\n            };\n            var derB = function () {\n                var res = dy;\n                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    res = res.sum(reduceAxes);\n                }\n                return res.neg().reshape(b.shape);\n            };\n            return { a: derA, b: derB };\n        };\n        return _environment.ENV.engine.runKernel(function (backend) {\n            return backend.subtract(a, b);\n        }, { a: a, b: b }, der);\n    };\n    BinaryOps.subStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');\n        return a.sub(b);\n    };\n    BinaryOps.pow = function (base, exp) {\n        util.assertArgumentsAreTensors({ base: base, exp: exp }, 'pow');\n        var outShape = broadcast_util.assertAndGetBroadcastShape(base.shape, exp.shape);\n        base = base.cast((0, _types.upcastType)(base.dtype, exp.dtype));\n        exp = exp.cast((0, _types.upcastType)(base.dtype, exp.dtype));\n        var grad = function (dy, saved) {\n            var y = saved[0];\n            var derBase = function () {\n                var res = dy.mul(exp.toFloat().mul(y.div(base)));\n                var reduceAxes = broadcast_util.getReductionAxes(base.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    res = res.sum(reduceAxes);\n                }\n                return res.reshape(base.shape);\n            };\n            var derExp = function () {\n                var res = dy.mul(y.mul(base.log()).toFloat());\n                var reduceAxes = broadcast_util.getReductionAxes(exp.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    res = res.sum(reduceAxes);\n                }\n                return res.reshape(exp.shape);\n            };\n            return { base: derBase, exp: derExp };\n        };\n        return _environment.ENV.engine.runKernel(function (backend, save) {\n            return save(backend.pow(base, exp));\n        }, { base: base, exp: exp }, grad);\n    };\n    BinaryOps.powStrict = function (base, exp) {\n        util.assertShapesMatch(base.shape, exp.shape, 'Error in powStrict: ');\n        return base.pow(exp);\n    };\n    BinaryOps.mul = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'mul');\n        util.assertTypesMatch(a, b);\n        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        var der = function (dy) {\n            var derA = function () {\n                var res = dy.mul(b.toFloat());\n                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    return res.sum(reduceAxes).reshape(a.shape);\n                }\n                return res;\n            };\n            var derB = function () {\n                var res = dy.mul(a.toFloat());\n                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    return res.sum(reduceAxes).reshape(b.shape);\n                }\n                return res;\n            };\n            return { a: derA, b: derB };\n        };\n        return _environment.ENV.engine.runKernel(function (backend) {\n            return backend.multiply(a, b);\n        }, { a: a, b: b }, der);\n    };\n    BinaryOps.mulStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');\n        return a.mul(b);\n    };\n    BinaryOps.div = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'div');\n        util.assertTypesMatch(a, b);\n        var forwardFunc;\n        if (a.dtype === 'int32' && b.dtype === 'int32') {\n            return BinaryOps.floorDiv(a, b);\n        } else {\n            forwardFunc = function (backend) {\n                return backend.realDivide(a, b);\n            };\n        }\n        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        var der = function (dy) {\n            var derA = function () {\n                var res = dy.div(b.toFloat());\n                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    return res.sum(reduceAxes).reshape(a.shape);\n                }\n                return res;\n            };\n            var derB = function () {\n                var res = dy.mul(a.toFloat());\n                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    res = res.sum(reduceAxes).reshape(b.shape);\n                }\n                var tmp = b.square();\n                return res.div(tmp.toFloat()).neg();\n            };\n            return { a: derA, b: derB };\n        };\n        return _environment.ENV.engine.runKernel(forwardFunc, { a: a, b: b }, der);\n    };\n    BinaryOps.floorDiv = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'floorDiv');\n        util.assertTypesMatch(a, b);\n        var forwardFunc = function (backend) {\n            return backend.floorDiv(a, b);\n        };\n        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        var der = function (dy) {\n            var derA = function () {\n                var res = dy.div(b.toFloat());\n                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    return res.sum(reduceAxes).reshape(a.shape);\n                }\n                return res;\n            };\n            var derB = function () {\n                var res = dy.mul(a.toFloat());\n                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    res = res.sum(reduceAxes).reshape(b.shape);\n                }\n                var tmp = b.square();\n                return res.div(tmp.toFloat()).neg();\n            };\n            return { a: derA, b: derB };\n        };\n        return _environment.ENV.engine.runKernel(forwardFunc, { a: a, b: b }, der);\n    };\n    BinaryOps.divStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');\n        return a.div(b);\n    };\n    BinaryOps.mod = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'mod');\n        util.assertTypesMatch(a, b);\n        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        var der = function (dy) {\n            var derA = function () {\n                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    return dy.sum(reduceAxes).reshape(a.shape);\n                }\n                return dy;\n            };\n            var derB = function () {\n                var res = dy.mul(a.div(b).floor().neg());\n                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    return res.sum(reduceAxes).reshape(b.shape);\n                }\n                return res;\n            };\n            return { a: derA, b: derB };\n        };\n        return _environment.ENV.engine.runKernel(function (backend) {\n            return backend.mod(a, b);\n        }, { a: a, b: b }, der);\n    };\n    BinaryOps.modStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in modStrict: ');\n        return a.mod(b);\n    };\n    BinaryOps.minimum = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'minimum');\n        util.assertTypesMatch(a, b);\n        if (a.dtype === 'bool') {\n            a = a.toInt();\n        }\n        if (b.dtype === 'bool') {\n            b = b.toInt();\n        }\n        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        var der = function (dy) {\n            var derA = function () {\n                return dy.mul(a.lessEqual(b).toFloat());\n            };\n            var derB = function () {\n                return dy.mul(a.greater(b).toFloat());\n            };\n            return { a: derA, b: derB };\n        };\n        return _environment.ENV.engine.runKernel(function (backend) {\n            return backend.minimum(a, b);\n        }, { a: a, b: b }, der);\n    };\n    BinaryOps.minimumStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');\n        return a.minimum(b);\n    };\n    BinaryOps.maximum = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'maximum');\n        util.assertTypesMatch(a, b);\n        if (a.dtype === 'bool') {\n            a = a.toInt();\n        }\n        if (b.dtype === 'bool') {\n            b = b.toInt();\n        }\n        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        var der = function (dy) {\n            var derA = function () {\n                return dy.mul(a.greaterEqual(b).toFloat());\n            };\n            var derB = function () {\n                return dy.mul(a.less(b).toFloat());\n            };\n            return { a: derA, b: derB };\n        };\n        return _environment.ENV.engine.runKernel(function (backend) {\n            return backend.maximum(a, b);\n        }, { a: a, b: b }, der);\n    };\n    BinaryOps.maximumStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');\n        return a.maximum(b);\n    };\n    BinaryOps.squaredDifference = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'squaredDifference');\n        util.assertTypesMatch(a, b);\n        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        var der = function (dy) {\n            var two = (0, _ops.scalar)(2);\n            var derA = function () {\n                return dy.mul(a.sub(b).mul(two));\n            };\n            var derB = function () {\n                return dy.mul(b.sub(a).mul(two));\n            };\n            return { a: derA, b: derB };\n        };\n        return _environment.ENV.engine.runKernel(function (backend) {\n            return backend.squaredDifference(a, b);\n        }, { a: a, b: b }, der);\n    };\n    BinaryOps.squaredDifferenceStrict = function (a, b) {\n        util.assertShapesMatch(a.shape, b.shape, 'Error in squaredDifferenceStrict: ');\n        return a.squaredDifference(b);\n    };\n    BinaryOps.atan2 = function (a, b) {\n        util.assertArgumentsAreTensors({ a: a, b: b }, 'atan2');\n        util.assertTypesMatch(a, b);\n        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);\n        var der = function (dy) {\n            var derA = function () {\n                var d = BinaryOps.add((0, _ops.square)(a), (0, _ops.square)(b));\n                var res = dy.mul(b.div(d));\n                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    res = res.sum(reduceAxes);\n                }\n                return res.reshape(a.shape);\n            };\n            var derB = function () {\n                var d = BinaryOps.add((0, _ops.square)(a), (0, _ops.square)(b));\n                var res = (0, _ops.neg)(dy.mul(a.div(d)));\n                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);\n                if (reduceAxes.length > 0) {\n                    res = res.sum(reduceAxes);\n                }\n                return res.reshape(b.shape);\n            };\n            return { a: derA, b: derB };\n        };\n        return _environment.ENV.engine.runKernel(function (backend) {\n            return backend.atan2(a, b);\n        }, { a: a, b: b }, der);\n    };\n    __decorate([(0, _doc.doc)({ heading: 'Operations', subheading: 'Arithmetic' }), _operation.operation], BinaryOps, \"add\", null);\n    __decorate([_operation.operation], BinaryOps, \"addStrict\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Operations', subheading: 'Arithmetic' }), _operation.operation], BinaryOps, \"sub\", null);\n    __decorate([_operation.operation], BinaryOps, \"subStrict\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Operations', subheading: 'Arithmetic' }), _operation.operation], BinaryOps, \"pow\", null);\n    __decorate([_operation.operation], BinaryOps, \"powStrict\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Operations', subheading: 'Arithmetic' }), _operation.operation], BinaryOps, \"mul\", null);\n    __decorate([_operation.operation], BinaryOps, \"mulStrict\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Operations', subheading: 'Arithmetic' }), _operation.operation], BinaryOps, \"div\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Operations', subheading: 'Arithmetic' }), _operation.operation], BinaryOps, \"floorDiv\", null);\n    __decorate([_operation.operation], BinaryOps, \"divStrict\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Operations', subheading: 'Arithmetic' }), _operation.operation], BinaryOps, \"mod\", null);\n    __decorate([_operation.operation], BinaryOps, \"modStrict\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Operations', subheading: 'Arithmetic' }), _operation.operation], BinaryOps, \"minimum\", null);\n    __decorate([_operation.operation], BinaryOps, \"minimumStrict\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Operations', subheading: 'Arithmetic' }), _operation.operation], BinaryOps, \"maximum\", null);\n    __decorate([_operation.operation], BinaryOps, \"maximumStrict\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Operations', subheading: 'Arithmetic' }), _operation.operation], BinaryOps, \"squaredDifference\", null);\n    __decorate([_operation.operation], BinaryOps, \"squaredDifferenceStrict\", null);\n    __decorate([_operation.operation], BinaryOps, \"atan2\", null);\n    return BinaryOps;\n}();\nexports.BinaryOps = BinaryOps;\n//# sourceMappingURL=binary_ops.js.map"},"hash":"b75feccd1ea73ae43a828d17a6ddca27","cacheData":{"env":{}}}