{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-layers/package.json","includedInParent":true,"mtime":1528724212618},{"name":"@tensorflow/tfjs-core","loc":{"line":11,"column":42}},{"name":"../activations","loc":{"line":12,"column":51}},{"name":"../backend/tfjs_backend","loc":{"line":13,"column":19}},{"name":"../constraints","loc":{"line":14,"column":51}},{"name":"../engine/topology","loc":{"line":15,"column":22}},{"name":"../errors","loc":{"line":16,"column":48}},{"name":"../initializers","loc":{"line":17,"column":53}},{"name":"../regularizers","loc":{"line":18,"column":53}},{"name":"../utils/generic_utils","loc":{"line":20,"column":36}},{"name":"../utils/math_utils","loc":{"line":21,"column":28}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Reshape = exports.RepeatVector = exports.Activation = exports.Flatten = exports.Dense = exports.Dropout = undefined;\n\nvar _tfjsCore = require('@tensorflow/tfjs-core');\n\nvar _activations = require('../activations');\n\nvar _tfjs_backend = require('../backend/tfjs_backend');\n\nvar K = _interopRequireWildcard(_tfjs_backend);\n\nvar _constraints = require('../constraints');\n\nvar _topology = require('../engine/topology');\n\nvar _errors = require('../errors');\n\nvar _initializers = require('../initializers');\n\nvar _regularizers = require('../regularizers');\n\nvar _generic_utils = require('../utils/generic_utils');\n\nvar generic_utils = _interopRequireWildcard(_generic_utils);\n\nvar _math_utils = require('../utils/math_utils');\n\nvar math_utils = _interopRequireWildcard(_math_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\n\nvar Dropout = function (_super) {\n    __extends(Dropout, _super);\n    function Dropout(config) {\n        var _this = _super.call(this, config) || this;\n        _this.rate = Math.max(Math.min(config.rate, 1), 0);\n        _this.rateScalar = K.getScalar(_this.rate);\n        _this.noiseShape = config.noiseShape;\n        _this.seed = config.seed;\n        if (_this.seed != null) {\n            throw new _errors.NotImplementedError('Non-default seed is not implemented in Dropout layer yet: ' + _this.seed);\n        }\n        _this.supportsMasking = true;\n        return _this;\n    }\n    Dropout.prototype.getNoiseShape = function (input) {\n        if (this.noiseShape == null) {\n            return this.noiseShape;\n        }\n        var inputShape = input.shape;\n        var noiseShape = [];\n        for (var i = 0; i < this.noiseShape.length; ++i) {\n            noiseShape.push(this.noiseShape[i] == null ? inputShape[i] : this.noiseShape[i]);\n        }\n        return noiseShape;\n    };\n    Dropout.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return (0, _tfjsCore.tidy)(function () {\n            _this.invokeCallHook(inputs, kwargs);\n            var input = generic_utils.getExactlyOneTensor(inputs);\n            if (_this.noiseShape != null && !_tfjsCore.util.arraysEqual(input.shape, _this.noiseShape)) {\n                throw new _errors.NotImplementedError('Non-default noise shape is not implemented in Dropout ' + 'layer yet: ' + JSON.stringify(_this.noiseShape));\n            }\n            if (0 < _this.rate && _this.rate < 1) {\n                var training = kwargs['training'] == null ? false : kwargs['training'];\n                var noiseShape_1 = _this.getNoiseShape(input);\n                var output = K.inTrainPhase(function () {\n                    return K.dropout(input, _this.rateScalar, noiseShape_1, _this.seed);\n                }, function () {\n                    return input;\n                }, training);\n                return output;\n            }\n            return inputs;\n        });\n    };\n    Dropout.prototype.getConfig = function () {\n        var config = {\n            rate: this.rate,\n            noiseShape: this.noiseShape,\n            seed: this.seed\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    Dropout.className = 'Dropout';\n    return Dropout;\n}(_topology.Layer);\nexports.Dropout = Dropout;\n\n_tfjsCore.serialization.SerializationMap.register(Dropout);\nvar Dense = function (_super) {\n    __extends(Dense, _super);\n    function Dense(config) {\n        var _this = _super.call(this, config) || this;\n        _this.activation = null;\n        _this.useBias = true;\n        _this.kernel = null;\n        _this.bias = null;\n        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';\n        if (config.batchInputShape == null && config.inputShape == null && config.inputDim != null) {\n            var batchSize = null;\n            if (config.batchSize != null) {\n                batchSize = config.batchSize;\n            }\n            _this.batchInputShape = [batchSize, config.inputDim];\n        }\n        _this.units = config.units;\n        _this.activation = (0, _activations.getActivation)(config.activation);\n        if (config.useBias != null) {\n            _this.useBias = config.useBias;\n        }\n        _this.kernelInitializer = (0, _initializers.getInitializer)(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);\n        _this.biasInitializer = (0, _initializers.getInitializer)(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);\n        _this.kernelConstraint = (0, _constraints.getConstraint)(config.kernelConstraint);\n        _this.biasConstraint = (0, _constraints.getConstraint)(config.biasConstraint);\n        _this.kernelRegularizer = (0, _regularizers.getRegularizer)(config.kernelRegularizer);\n        _this.biasRegularizer = (0, _regularizers.getRegularizer)(config.biasRegularizer);\n        _this.activityRegularizer = (0, _regularizers.getRegularizer)(config.activityRegularizer);\n        _this.inputSpec = [{ minNDim: 2 }];\n        return _this;\n    }\n    Dense.prototype.build = function (inputShape) {\n        inputShape = generic_utils.getExactlyOneShape(inputShape);\n        var inputLastDim = inputShape[inputShape.length - 1];\n        if (this.kernel == null) {\n            this.kernel = this.addWeight('kernel', [inputLastDim, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n            if (this.useBias) {\n                this.bias = this.addWeight('bias', [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n            }\n        }\n        this.inputSpec = [{ minNDim: 2, axes: (_a = {}, _a[-1] = inputLastDim, _a) }];\n        this.built = true;\n        var _a;\n    };\n    Dense.prototype.computeOutputShape = function (inputShape) {\n        inputShape = generic_utils.getExactlyOneShape(inputShape);\n        var outputShape = inputShape.slice();\n        outputShape[outputShape.length - 1] = this.units;\n        return outputShape;\n    };\n    Dense.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return (0, _tfjsCore.tidy)(function () {\n            _this.invokeCallHook(inputs, kwargs);\n            var input = generic_utils.getExactlyOneTensor(inputs);\n            var output = K.dot(input, _this.kernel.read());\n            if (_this.bias != null) {\n                output = K.biasAdd(output, _this.bias.read());\n            }\n            if (_this.activation != null) {\n                output = _this.activation.apply(output);\n            }\n            return output;\n        });\n    };\n    Dense.prototype.getConfig = function () {\n        var config = {\n            units: this.units,\n            activation: (0, _activations.serializeActivation)(this.activation),\n            useBias: this.useBias,\n            kernelInitializer: (0, _initializers.serializeInitializer)(this.kernelInitializer),\n            biasInitializer: (0, _initializers.serializeInitializer)(this.biasInitializer),\n            kernelRegularizer: (0, _regularizers.serializeRegularizer)(this.kernelRegularizer),\n            biasRegularizer: (0, _regularizers.serializeRegularizer)(this.biasRegularizer),\n            activityRegularizer: (0, _regularizers.serializeRegularizer)(this.activityRegularizer),\n            kernelConstraint: (0, _constraints.serializeConstraint)(this.kernelConstraint),\n            biasConstraint: (0, _constraints.serializeConstraint)(this.biasConstraint)\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    Dense.className = 'Dense';\n    return Dense;\n}(_topology.Layer);\nexports.Dense = Dense;\n\n_tfjsCore.serialization.SerializationMap.register(Dense);\nvar Flatten = function (_super) {\n    __extends(Flatten, _super);\n    function Flatten(config) {\n        var _this = _super.call(this, config || {}) || this;\n        _this.inputSpec = [{ minNDim: 3 }];\n        return _this;\n    }\n    Flatten.prototype.computeOutputShape = function (inputShape) {\n        inputShape = generic_utils.getExactlyOneShape(inputShape);\n        for (var _i = 0, _a = inputShape.slice(1); _i < _a.length; _i++) {\n            var dim = _a[_i];\n            if (dim == null) {\n                throw new _errors.ValueError(\"The shape of the input to \\\"Flatten\\\" is not fully defined \" + (\"(got \" + inputShape.slice(1) + \"). Make sure to pass a complete \") + \"\\\"input_shape\\\" or \\\"batch_input_shape\\\" argument to the first \" + \"layer in your model.\");\n            }\n        }\n        return [inputShape[0], math_utils.arrayProd(inputShape, 1)];\n    };\n    Flatten.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return (0, _tfjsCore.tidy)(function () {\n            _this.invokeCallHook(inputs, kwargs);\n            return K.batchFlatten(generic_utils.getExactlyOneTensor(inputs));\n        });\n    };\n    Flatten.className = 'Flatten';\n    return Flatten;\n}(_topology.Layer);\nexports.Flatten = Flatten;\n\n_tfjsCore.serialization.SerializationMap.register(Flatten);\nvar Activation = function (_super) {\n    __extends(Activation, _super);\n    function Activation(config) {\n        var _this = _super.call(this, config) || this;\n        _this.supportsMasking = true;\n        _this.activation = (0, _activations.getActivation)(config.activation);\n        return _this;\n    }\n    Activation.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return (0, _tfjsCore.tidy)(function () {\n            _this.invokeCallHook(inputs, kwargs);\n            var input = generic_utils.getExactlyOneTensor(inputs);\n            return _this.activation.apply(input);\n        });\n    };\n    Activation.prototype.getConfig = function () {\n        var config = { activation: (0, _activations.serializeActivation)(this.activation) };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    Activation.className = 'Activation';\n    return Activation;\n}(_topology.Layer);\nexports.Activation = Activation;\n\n_tfjsCore.serialization.SerializationMap.register(Activation);\nvar RepeatVector = function (_super) {\n    __extends(RepeatVector, _super);\n    function RepeatVector(config) {\n        var _this = _super.call(this, config) || this;\n        _this.n = config.n;\n        _this.inputSpec = [{ ndim: 2 }];\n        return _this;\n    }\n    RepeatVector.prototype.computeOutputShape = function (inputShape) {\n        return [inputShape[0], this.n, inputShape[1]];\n    };\n    RepeatVector.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return (0, _tfjsCore.tidy)(function () {\n            inputs = (0, _generic_utils.getExactlyOneTensor)(inputs);\n            return K.repeat(inputs, _this.n);\n        });\n    };\n    RepeatVector.prototype.getConfig = function () {\n        var config = {\n            n: this.n\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    RepeatVector.className = 'RepeatVector';\n    return RepeatVector;\n}(_topology.Layer);\nexports.RepeatVector = RepeatVector;\n\n_tfjsCore.serialization.SerializationMap.register(RepeatVector);\nvar Reshape = function (_super) {\n    __extends(Reshape, _super);\n    function Reshape(config) {\n        var _this = _super.call(this, config) || this;\n        _this.targetShape = config.targetShape;\n        for (var i = 0; i < _this.targetShape.length; ++i) {\n            if (_this.isUnknown(_this.targetShape[i])) {\n                _this.targetShape[i] = null;\n            }\n        }\n        return _this;\n    }\n    Reshape.prototype.isUnknown = function (dim) {\n        return dim < 0 || dim == null;\n    };\n    Reshape.prototype.fixUnknownDimension = function (inputShape, outputShape) {\n        var errorMsg = 'Total size of new array must be unchanged.';\n        var finalShape = outputShape.slice();\n        var known = 1;\n        var unknown = null;\n        for (var i = 0; i < finalShape.length; ++i) {\n            var dim = finalShape[i];\n            if (this.isUnknown(dim)) {\n                if (unknown === null) {\n                    unknown = i;\n                } else {\n                    throw new _errors.ValueError('Can only specifiy one unknown dimension.');\n                }\n            } else {\n                known *= dim;\n            }\n        }\n        var originalSize = math_utils.arrayProd(inputShape);\n        if (unknown !== null) {\n            if (known === 0 || originalSize % known !== 0) {\n                throw new _errors.ValueError(errorMsg);\n            }\n            finalShape[unknown] = originalSize / known;\n        } else if (originalSize !== known) {\n            throw new _errors.ValueError(errorMsg);\n        }\n        return finalShape;\n    };\n    Reshape.prototype.computeOutputShape = function (inputShape) {\n        var anyUnknownDims = false;\n        for (var i = 0; i < inputShape.length; ++i) {\n            if (this.isUnknown(inputShape[i])) {\n                anyUnknownDims = true;\n                break;\n            }\n        }\n        if (anyUnknownDims) {\n            return inputShape.slice(0, 1).concat(this.targetShape);\n        } else {\n            return inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));\n        }\n    };\n    Reshape.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return (0, _tfjsCore.tidy)(function () {\n            _this.invokeCallHook(inputs, kwargs);\n            var input = generic_utils.getExactlyOneTensor(inputs);\n            var inputShape = K.shape(input);\n            var outputShape = inputShape.slice(0, 1).concat(_this.fixUnknownDimension(inputShape.slice(1), _this.targetShape));\n            return input.reshape(outputShape);\n        });\n    };\n    Reshape.prototype.getConfig = function () {\n        var config = {\n            targetShape: this.targetShape\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    Reshape.className = 'Reshape';\n    return Reshape;\n}(_topology.Layer);\nexports.Reshape = Reshape;\n\n_tfjsCore.serialization.SerializationMap.register(Reshape);\n//# sourceMappingURL=core.js.map"},"hash":"99c516aebd8c5afc3c140a6b4f940cbd","cacheData":{"env":{}}}