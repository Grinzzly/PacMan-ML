{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-converter/package.json","includedInParent":true,"mtime":1528724212618},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-converter/.babelrc","includedInParent":true,"mtime":1528724212614},{"name":"@tensorflow/tfjs-core","loc":{"line":1,"column":21}},{"name":"./utils","loc":{"line":2,"column":30}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.CATEGORY = exports.executeOp = undefined;\n\nvar _tfjsCore = require('@tensorflow/tfjs-core');\n\nvar tfc = _interopRequireWildcard(_tfjsCore);\n\nvar _utils = require('./utils');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar executeOp = exports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'conv1d':\n            {\n                var stride = (0, _utils.getParamValue)('stride', node, tensorMap, context);\n                var pad = (0, _utils.getParamValue)('pad', node, tensorMap, context);\n                var dataFormat = (0, _utils.getParamValue)('dataFormat', node, tensorMap, context).toUpperCase();\n                var dilation = (0, _utils.getParamValue)('dilation', node, tensorMap, context);\n                return [tfc.conv1d((0, _utils.getParamValue)('x', node, tensorMap, context), (0, _utils.getParamValue)('filter', node, tensorMap, context), stride, pad, dataFormat, dilation)];\n            }\n        case 'conv2d':\n            {\n                var stride = (0, _utils.getParamValue)('strides', node, tensorMap, context);\n                var pad = (0, _utils.getParamValue)('pad', node, tensorMap, context);\n                var dataFormat = (0, _utils.getParamValue)('dataFormat', node, tensorMap, context).toUpperCase();\n                var dilations = (0, _utils.getParamValue)('dilations', node, tensorMap, context);\n                return [tfc.conv2d((0, _utils.getParamValue)('x', node, tensorMap, context), (0, _utils.getParamValue)('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])];\n            }\n        case 'conv2dTranspose':\n            {\n                var shape = (0, _utils.getParamValue)('outputShape', node, tensorMap, context);\n                var stride = (0, _utils.getParamValue)('strides', node, tensorMap, context);\n                var pad = (0, _utils.getParamValue)('pad', node, tensorMap, context);\n                return [tfc.conv2dTranspose((0, _utils.getParamValue)('x', node, tensorMap, context), (0, _utils.getParamValue)('filter', node, tensorMap, context), shape, [stride[1], stride[2]], pad)];\n            }\n        case 'depthwiseConv2d':\n            {\n                var stride = (0, _utils.getParamValue)('strides', node, tensorMap, context);\n                var pad = (0, _utils.getParamValue)('pad', node, tensorMap, context);\n                var dilations = (0, _utils.getParamValue)('dilations', node, tensorMap, context);\n                var dataFormat = (0, _utils.getParamValue)('dataFormat', node, tensorMap, context).toUpperCase();\n                return [tfc.depthwiseConv2d((0, _utils.getParamValue)('input', node, tensorMap, context), (0, _utils.getParamValue)('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[0], dilations[1]])];\n            }\n        case 'avgPool':\n            {\n                var stride = (0, _utils.getParamValue)('strides', node, tensorMap, context);\n                var pad = (0, _utils.getParamValue)('pad', node, tensorMap, context);\n                var kernelSize = (0, _utils.getParamValue)('kernelSize', node, tensorMap, context);\n                return [tfc.avgPool((0, _utils.getParamValue)('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];\n            }\n        case 'maxPool':\n            {\n                var stride = (0, _utils.getParamValue)('strides', node, tensorMap, context);\n                var pad = (0, _utils.getParamValue)('pad', node, tensorMap, context);\n                var kernelSize = (0, _utils.getParamValue)('kernelSize', node, tensorMap, context);\n                return [tfc.maxPool((0, _utils.getParamValue)('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];\n            }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nvar CATEGORY = exports.CATEGORY = 'convolution';\n//# sourceMappingURL=convolution_executor.js.map"},"hash":"49e09b51d4b601286143b17b50438183","cacheData":{"env":{}}}