{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-converter/package.json","includedInParent":true,"mtime":1528724212618},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-converter/.babelrc","includedInParent":true,"mtime":1528724212614},{"name":"@tensorflow/tfjs-core","loc":{"line":44,"column":21}},{"name":"../operations/executors/utils","loc":{"line":45,"column":47}},{"name":"../operations/operation_executor","loc":{"line":46,"column":26}},{"name":"./execution_context","loc":{"line":47,"column":33}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.GraphExecutor = undefined;\n\nvar _tfjsCore = require(\"@tensorflow/tfjs-core\");\n\nvar _utils = require(\"../operations/executors/utils\");\n\nvar _operation_executor = require(\"../operations/operation_executor\");\n\nvar _execution_context = require(\"./execution_context\");\n\nvar __assign = undefined && undefined.__assign || Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n};\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : new P(function (resolve) {\n                resolve(result.value);\n            }).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n    var _ = { label: 0, sent: function () {\n            if (t[0] & 1) throw t[1];return t[1];\n        }, trys: [], ops: [] },\n        f,\n        y,\n        t,\n        g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n    }), g;\n    function verb(n) {\n        return function (v) {\n            return step([n, v]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0:case 1:\n                    t = op;break;\n                case 4:\n                    _.label++;return { value: op[1], done: false };\n                case 5:\n                    _.label++;y = op[1];op = [0];continue;\n                case 7:\n                    op = _.ops.pop();_.trys.pop();continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];t = op;break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];_.ops.push(op);break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [6, e];y = 0;\n        } finally {\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar GraphExecutor = function () {\n    function GraphExecutor(graph) {\n        this.graph = graph;\n        this.compiledOrder = [];\n        this._weightMap = {};\n        this.placeholders = graph.placeholders.map(function (node) {\n            return node.name;\n        });\n        this.outputs = graph.outputs.map(function (node) {\n            return node.name;\n        });\n        this.compile();\n    }\n    Object.defineProperty(GraphExecutor.prototype, \"weightMap\", {\n        get: function () {\n            return this._weightMap;\n        },\n        set: function (weightMap) {\n            var weightIds = Object.keys(weightMap).map(function (key) {\n                return weightMap[key].map(function (tensor) {\n                    return tensor.id;\n                });\n            });\n            this.weightIds = [].concat.apply([], weightIds);\n            this._weightMap = weightMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"inputNodes\", {\n        get: function () {\n            return this.placeholders;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"outputNodes\", {\n        get: function () {\n            return this.outputs;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"isControlFlowModel\", {\n        get: function () {\n            return this.graph.withControlFlow;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GraphExecutor.prototype.compile = function () {\n        if (this.graph.withControlFlow) {\n            return;\n        }\n        var stack = this.graph.inputs.slice();\n        var visited = {};\n        while (stack.length > 0) {\n            var node = stack.pop();\n            visited[node.name] = true;\n            this.compiledOrder.push(node);\n            node.children.forEach(function (childNode) {\n                if (!visited[childNode.name] && childNode.inputNames.every(function (name) {\n                    var nodeName = (0, _utils.getNodeNameAndIndex)(name)[0];\n                    return visited[nodeName];\n                })) {\n                    stack.push(childNode);\n                }\n            });\n        }\n    };\n    GraphExecutor.prototype.execute = function (inputs, outputs) {\n        var _this = this;\n        this.checkInput(inputs);\n        var result = (0, _tfjsCore.tidy)(function () {\n            var context = new _execution_context.ExecutionContext(_this._weightMap);\n            var tensors = _this.compiledOrder.reduce(function (map, node) {\n                map[node.name] = (0, _operation_executor.executeOp)(node, map, context);\n                return map;\n            }, __assign({}, _this.weightMap, inputs));\n            return _this.findOutputs(tensors, context, outputs);\n        });\n        return result;\n    };\n    GraphExecutor.prototype.executeAsync = function (inputs, outputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            var context, tensors, results, outputIds, inputIdArray, inputIds;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        context = new _execution_context.ExecutionContext(this._weightMap);\n                        return [4, this.executeWithControlFlow(inputs, context)];\n                    case 1:\n                        tensors = _a.sent();\n                        results = this.findOutputs(tensors, context, outputs);\n                        outputIds = Object.keys(results).map(function (key) {\n                            return results[key].id;\n                        });\n                        inputIdArray = Object.keys(inputs).map(function (key) {\n                            return inputs[key].map(function (input) {\n                                return input.id;\n                            });\n                        });\n                        inputIds = [].concat.apply([], inputIdArray);\n                        Object.keys(tensors).forEach(function (key) {\n                            var tensorArray = tensors[key];\n                            tensorArray.forEach(function (tensor) {\n                                if (tensor && outputIds.indexOf(tensor.id) === -1 && inputIds.indexOf(tensor.id) === -1 && _this.weightIds.indexOf(tensor.id) === -1) {\n                                    tensor.dispose();\n                                }\n                            });\n                        });\n                        return [2, results];\n                }\n            });\n        });\n    };\n    GraphExecutor.prototype.executeWithControlFlow = function (inputs, context) {\n        return __awaiter(this, void 0, void 0, function () {\n            var stack, tensorMap, added, item, tensors, nodeName, _a, _b;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        stack = this.graph.inputs.map(function (node) {\n                            return { node: node, contexts: context.currentContext };\n                        });\n                        tensorMap = __assign({}, this.weightMap, inputs);\n                        added = {};\n                        _c.label = 1;\n                    case 1:\n                        if (!(stack.length > 0)) return [3, 3];\n                        item = stack.pop();\n                        context.currentContext = item.contexts;\n                        tensors = (0, _operation_executor.executeOp)(item.node, tensorMap, context);\n                        nodeName = (0, _utils.getNodeNameAndIndex)(item.node.name, context)[0];\n                        _a = tensorMap;\n                        _b = nodeName;\n                        return [4, tensors];\n                    case 2:\n                        _a[_b] = _c.sent();\n                        item.node.children.forEach(function (childNode) {\n                            var nodeName = (0, _utils.getNodeNameAndIndex)(childNode.name, context)[0];\n                            if (!added[nodeName]) {\n                                if (childNode.op === 'merge') {\n                                    if (childNode.inputNames.some(function (name) {\n                                        return !!(0, _utils.getTensor)(name, tensorMap, context);\n                                    })) {\n                                        added[nodeName] = true;\n                                        stack.push({ contexts: context.currentContext, node: childNode });\n                                    }\n                                } else if (childNode.inputNames.every(function (name) {\n                                    return !!(0, _utils.getTensor)(name, tensorMap, context);\n                                })) {\n                                    added[nodeName] = true;\n                                    stack.push({ contexts: context.currentContext, node: childNode });\n                                }\n                            }\n                        });\n                        return [3, 1];\n                    case 3:\n                        return [2, tensorMap];\n                }\n            });\n        });\n    };\n    GraphExecutor.prototype.findOutputs = function (tensorMap, context, outputs) {\n        if (outputs && !(outputs instanceof Array)) {\n            outputs = [outputs];\n        }\n        var requestedOutputs = outputs || this.graph.outputs.map(function (node) {\n            return node.name;\n        });\n        return requestedOutputs.reduce(function (map, name) {\n            map[name] = (0, _utils.getTensor)(name, tensorMap, context);\n            return map;\n        }, {});\n    };\n    GraphExecutor.prototype.dispose = function () {\n        var _this = this;\n        Object.keys(this.weightMap).forEach(function (key) {\n            return _this.weightMap[key].forEach(function (tensor) {\n                return tensor.dispose();\n            });\n        });\n    };\n    GraphExecutor.prototype.checkInput = function (inputs) {\n        var _this = this;\n        var inputKeys = Object.keys(inputs);\n        var missing = [];\n        var extra = [];\n        this.placeholders.forEach(function (name) {\n            if (inputKeys.indexOf(name) === -1) missing.push(name);\n        });\n        inputKeys.forEach(function (name) {\n            if (_this.placeholders.indexOf(name) === -1) extra.push(name);\n        });\n        if (missing.length > 0) {\n            throw new Error(\"The dict provided in model.execute(dict) has the keys \" + (\"[\" + inputKeys + \"], but is missing the required keys: [\" + missing + \"].\"));\n        }\n        if (extra.length > 0) {\n            throw new Error(\"The dict provided in model.execute(dict) has \" + (\"unused keys: [\" + extra + \"]. Please provide only the following keys: \") + (\"[\" + this.placeholders + \"].\"));\n        }\n    };\n    return GraphExecutor;\n}();\nexports.GraphExecutor = GraphExecutor;\n//# sourceMappingURL=graph_executor.js.map"},"hash":"d4dfa5f7ec7481cfec5eec676f12976e","cacheData":{"env":{}}}