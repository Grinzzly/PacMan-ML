{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-core/package.json","includedInParent":true,"mtime":1528724212618},{"name":"../doc","loc":{"line":7,"column":20}},{"name":"../util","loc":{"line":8,"column":22}},{"name":"./operation","loc":{"line":9,"column":26}},{"name":"./ops","loc":{"line":10,"column":21}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.LossOps = exports.Reduction = undefined;\n\nvar _doc = require(\"../doc\");\n\nvar _util = require(\"../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _operation = require(\"./operation\");\n\nvar _ops = require(\"./ops\");\n\nvar ops = _interopRequireWildcard(_ops);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Reduction = exports.Reduction = undefined;\n(function (Reduction) {\n    Reduction[Reduction[\"NONE\"] = 0] = \"NONE\";\n    Reduction[Reduction[\"MEAN\"] = 1] = \"MEAN\";\n    Reduction[Reduction[\"SUM\"] = 2] = \"SUM\";\n    Reduction[Reduction[\"SUM_BY_NONZERO_WEIGHTS\"] = 3] = \"SUM_BY_NONZERO_WEIGHTS\";\n})(Reduction || (exports.Reduction = Reduction = {}));\nvar LossOps = function () {\n    function LossOps() {}\n    LossOps.computeWeightedLoss = function (losses, weights, reduction) {\n        if (reduction === void 0) {\n            reduction = Reduction.SUM_BY_NONZERO_WEIGHTS;\n        }\n        util.assertArgumentsAreTensors({ losses: losses }, 'computeWeightedLoss');\n        if (weights != null) {\n            util.assertArgumentsAreTensors({ weights: weights }, 'computeWeightedLoss');\n        }\n        var weightedLoss = weights == null ? losses : losses.mul(weights);\n        if (reduction === Reduction.NONE) {\n            return weightedLoss;\n        }\n        if (reduction === Reduction.SUM) {\n            return weightedLoss.sum();\n        }\n        if (reduction === Reduction.MEAN) {\n            return weights == null ? weightedLoss.mean() : weightedLoss.sum().div(weights.sum());\n        }\n        if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n            if (weights == null) {\n                return weightedLoss.sum().div(ops.scalar(losses.size));\n            } else {\n                var numNonZeros = weights.notEqual(ops.scalar(0)).sum().toFloat();\n                return weightedLoss.sum().div(numNonZeros);\n            }\n        }\n        throw Error(\"Unknown reduction: \" + reduction);\n    };\n    LossOps.absoluteDifference = function (labels, predictions, weights, reduction) {\n        if (reduction === void 0) {\n            reduction = Reduction.SUM_BY_NONZERO_WEIGHTS;\n        }\n        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'absoluteDifference');\n        if (weights != null) {\n            util.assertArgumentsAreTensors({ weights: weights }, 'absoluteDifference');\n        }\n        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in absoluteDifference: ');\n        var losses = labels.sub(predictions).abs();\n        return LossOps.computeWeightedLoss(losses, weights, reduction);\n    };\n    LossOps.meanSquaredError = function (labels, predictions, weights, reduction) {\n        if (reduction === void 0) {\n            reduction = Reduction.SUM_BY_NONZERO_WEIGHTS;\n        }\n        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'meanSquaredError');\n        if (weights != null) {\n            util.assertArgumentsAreTensors({ weights: weights }, 'meanSquaredError');\n        }\n        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in meanSquaredError: ');\n        var losses = labels.squaredDifference(predictions);\n        return LossOps.computeWeightedLoss(losses, weights, reduction);\n    };\n    LossOps.cosineDistance = function (labels, predictions, axis, weights, reduction) {\n        if (reduction === void 0) {\n            reduction = Reduction.SUM_BY_NONZERO_WEIGHTS;\n        }\n        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'cosineDistance');\n        if (weights != null) {\n            util.assertArgumentsAreTensors({ weights: weights }, 'cosineDistance');\n        }\n        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in cosineDistance: ');\n        var one = ops.scalar(1);\n        var losses = one.sub(labels.mul(predictions).sum(axis, true));\n        return LossOps.computeWeightedLoss(losses, weights, reduction);\n    };\n    LossOps.hingeLoss = function (labels, predictions, weights, reduction) {\n        if (reduction === void 0) {\n            reduction = Reduction.SUM_BY_NONZERO_WEIGHTS;\n        }\n        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'hingeLoss');\n        if (weights != null) {\n            util.assertArgumentsAreTensors({ weights: weights }, 'hingeLoss');\n        }\n        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in hingeLoss: ');\n        var one = ops.scalar(1);\n        labels = ops.scalar(2).mul(labels).sub(one);\n        var losses = one.sub(labels.mul(predictions)).relu();\n        return LossOps.computeWeightedLoss(losses, weights, reduction);\n    };\n    LossOps.logLoss = function (labels, predictions, weights, epsilon, reduction) {\n        if (epsilon === void 0) {\n            epsilon = 1e-7;\n        }\n        if (reduction === void 0) {\n            reduction = Reduction.SUM_BY_NONZERO_WEIGHTS;\n        }\n        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'logLoss');\n        if (weights != null) {\n            util.assertArgumentsAreTensors({ weights: weights }, 'logLoss');\n        }\n        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in logLoss: ');\n        var one = ops.scalar(1);\n        var epsilonScalar = ops.scalar(epsilon);\n        var losses = labels.mul(predictions.add(epsilonScalar).log()).neg().sub(one.sub(labels).mul(one.sub(predictions).add(epsilonScalar).log()));\n        return LossOps.computeWeightedLoss(losses, weights, reduction);\n    };\n    LossOps.huberLoss = function (labels, predictions, weights, delta, reduction) {\n        if (delta === void 0) {\n            delta = 1.0;\n        }\n        if (reduction === void 0) {\n            reduction = Reduction.SUM_BY_NONZERO_WEIGHTS;\n        }\n        util.assertArgumentsAreTensors({ labels: labels, predictions: predictions }, 'huberLoss');\n        if (weights != null) {\n            util.assertArgumentsAreTensors({ weights: weights }, 'huberLoss');\n        }\n        util.assertShapesMatch(labels.shape, predictions.shape, 'Error in huberLoss: ');\n        var deltaScalar = ops.scalar(delta);\n        var error = predictions.sub(labels).abs();\n        var quadratic = ops.minimum(error, deltaScalar);\n        var linear = error.sub(quadratic);\n        var losses = ops.scalar(0.5).mul(quadratic.square()).add(deltaScalar.mul(linear));\n        return LossOps.computeWeightedLoss(losses, weights, reduction);\n    };\n    __decorate([(0, _doc.doc)({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }), _operation.operation], LossOps, \"computeWeightedLoss\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }), _operation.operation], LossOps, \"absoluteDifference\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }), _operation.operation], LossOps, \"meanSquaredError\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }), _operation.operation], LossOps, \"cosineDistance\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }), _operation.operation], LossOps, \"hingeLoss\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }), _operation.operation], LossOps, \"logLoss\", null);\n    __decorate([(0, _doc.doc)({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }), _operation.operation], LossOps, \"huberLoss\", null);\n    return LossOps;\n}();\nexports.LossOps = LossOps;\n//# sourceMappingURL=loss_ops.js.map"},"hash":"15d67ace704ef678427f3560097ec716","cacheData":{"env":{}}}