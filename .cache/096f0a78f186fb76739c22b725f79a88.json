{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-converter/package.json","includedInParent":true,"mtime":1528724212618},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-converter/.babelrc","includedInParent":true,"mtime":1528724212614},{"name":"@tensorflow/tfjs-core","loc":{"line":1,"column":21}},{"name":"./utils","loc":{"line":2,"column":30}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.CATEGORY = exports.executeOp = undefined;\n\nvar _tfjsCore = require('@tensorflow/tfjs-core');\n\nvar tfc = _interopRequireWildcard(_tfjsCore);\n\nvar _utils = require('./utils');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar executeOp = exports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'concat':\n            {\n                var axis = (0, _utils.getParamValue)('axis', node, tensorMap, context);\n                var inputs = (0, _utils.getParamValue)('tensors', node, tensorMap, context);\n                return [tfc.concat(inputs, axis)];\n            }\n        case 'gather':\n            {\n                var axis = (0, _utils.getParamValue)('axis', node, tensorMap, context);\n                var input = (0, _utils.getParamValue)('x', node, tensorMap, context);\n                var indices = (0, _utils.getParamValue)('indices', node, tensorMap, context);\n                return [tfc.gather(input, indices, axis)];\n            }\n        case 'reverse':\n            {\n                var axis = (0, _utils.getParamValue)('axis', node, tensorMap, context);\n                var input = (0, _utils.getParamValue)('x', node, tensorMap, context);\n                return [tfc.reverse(input, axis)];\n            }\n        case 'slice':\n            {\n                var begin = (0, _utils.getParamValue)('begin', node, tensorMap, context);\n                var size = (0, _utils.getParamValue)('size', node, tensorMap, context);\n                return [tfc.slice((0, _utils.getParamValue)('x', node, tensorMap, context), begin, size)];\n            }\n        case 'stridedSlice':\n            {\n                var begin = (0, _utils.getParamValue)('begin', node, tensorMap, context);\n                var end = (0, _utils.getParamValue)('end', node, tensorMap, context);\n                var strides = (0, _utils.getParamValue)('strides', node, tensorMap, context);\n                var beginMask = (0, _utils.getParamValue)('beginMask', node, tensorMap, context);\n                var endMask = (0, _utils.getParamValue)('endMask', node, tensorMap, context);\n                return [tfc.stridedSlice((0, _utils.getParamValue)('x', node, tensorMap, context), begin, end, strides, beginMask, endMask)];\n            }\n        case 'stack':\n            {\n                return tfc.tidy(function () {\n                    var axis = (0, _utils.getParamValue)('axis', node, tensorMap, context);\n                    var tensors = (0, _utils.getParamValue)('tensors', node, tensorMap, context);\n                    var shape = tensors[0].shape;\n                    var squeezedShape = tensors[0].squeeze().shape;\n                    var mapped = tensors.map(function (tensor) {\n                        var sameShape = tfc.util.arraysEqual(tensor.shape, shape);\n                        if (!sameShape && !tfc.util.arraysEqual(tensor.squeeze().shape, squeezedShape)) {\n                            throw new Error('the input tensors shape does not match');\n                        }\n                        return sameShape ? tensor : tensor.reshape(shape);\n                    });\n                    return [tfc.stack(mapped, axis)];\n                });\n            }\n        case 'tile':\n            {\n                var reps = (0, _utils.getParamValue)('reps', node, tensorMap, context);\n                return [tfc.tile((0, _utils.getParamValue)('x', node, tensorMap, context), reps)];\n            }\n        case 'split':\n            {\n                var axis = (0, _utils.getParamValue)('axis', node, tensorMap, context);\n                var numOrSizeSplits = (0, _utils.getParamValue)('numOrSizeSplits', node, tensorMap, context);\n                return tfc.split((0, _utils.getParamValue)('x', node, tensorMap, context), numOrSizeSplits, axis);\n            }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nvar CATEGORY = exports.CATEGORY = 'slice_join';\n//# sourceMappingURL=slice_join_executor.js.map"},"hash":"ced06a439afed842b683ccbc3e2b09d0","cacheData":{"env":{}}}