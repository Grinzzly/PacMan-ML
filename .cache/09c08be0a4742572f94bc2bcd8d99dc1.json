{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-converter/package.json","includedInParent":true,"mtime":1528724212618},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-converter/.babelrc","includedInParent":true,"mtime":1528724212614},{"name":"@tensorflow/tfjs-core","loc":{"line":1,"column":21}},{"name":"./utils","loc":{"line":2,"column":41}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.CATEGORY = exports.executeOp = undefined;\n\nvar _tfjsCore = require('@tensorflow/tfjs-core');\n\nvar tfc = _interopRequireWildcard(_tfjsCore);\n\nvar _utils = require('./utils');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar executeOp = exports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'abs':\n            return [tfc.abs((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'acos':\n            return [tfc.acos((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'acosh':\n            return [tfc.acosh((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'asin':\n            return [tfc.asin((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'asinh':\n            return [tfc.asinh((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'atan':\n            return [tfc.atan((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'atanh':\n            return [tfc.atanh((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'ceil':\n            return [tfc.ceil((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'cos':\n            return [tfc.cos((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'cosh':\n            return [tfc.cosh((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'elu':\n            return [tfc.elu((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'erf':\n            return [tfc.erf((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'exp':\n            return [tfc.exp((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'expm1':\n            {\n                return [tfc.expm1((0, _utils.getParamValue)('x', node, tensorMap, context))];\n            }\n        case 'floor':\n            return [tfc.floor((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'log':\n            return [tfc.log((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'log1p':\n            {\n                return [tfc.log1p((0, _utils.getParamValue)('x', node, tensorMap, context))];\n            }\n        case 'neg':\n            return [tfc.neg((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'reciprocal':\n            {\n                return [tfc.reciprocal((0, _utils.getParamValue)('x', node, tensorMap, context))];\n            }\n        case 'relu':\n            return [tfc.relu((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'round':\n            {\n                return [tfc.round((0, _utils.getParamValue)('x', node, tensorMap, context))];\n            }\n        case 'selu':\n            return [tfc.selu((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'sigmoid':\n            return [tfc.sigmoid((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'sin':\n            return [tfc.sin((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'sign':\n            {\n                return [tfc.sign((0, _utils.getParamValue)('x', node, tensorMap, context))];\n            }\n        case 'sinh':\n            {\n                return [tfc.sinh((0, _utils.getParamValue)('x', node, tensorMap, context))];\n            }\n        case 'softplus':\n            {\n                return [tfc.softplus((0, _utils.getParamValue)('x', node, tensorMap, context))];\n            }\n        case 'sqrt':\n            {\n                return [tfc.sqrt((0, _utils.getParamValue)('x', node, tensorMap, context))];\n            }\n        case 'square':\n            {\n                return [tfc.square((0, _utils.getParamValue)('x', node, tensorMap, context))];\n            }\n        case 'tanh':\n            {\n                return [tfc.tanh((0, _utils.getParamValue)('x', node, tensorMap, context))];\n            }\n        case 'tan':\n            return [tfc.tan((0, _utils.getParamValue)('x', node, tensorMap, context))];\n        case 'clipByValue':\n            return [tfc.clipByValue((0, _utils.getParamValue)('x', node, tensorMap, context), (0, _utils.getParamValue)('clipValueMin', node, tensorMap, context), (0, _utils.getParamValue)('clipValueMax', node, tensorMap, context))];\n        case 'rsqrt':\n            return [tfc.div(tfc.scalar(1.0, 'float32'), tfc.sqrt((0, _utils.getTensor)(node.inputNames[0], tensorMap, context)))];\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nvar CATEGORY = exports.CATEGORY = 'basic_math';\n//# sourceMappingURL=basic_math_executor.js.map"},"hash":"378b949c9434e454521795d3700319d7","cacheData":{"env":{}}}