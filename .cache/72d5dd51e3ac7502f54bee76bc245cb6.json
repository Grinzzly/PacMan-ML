{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/.babelrc","includedInParent":true,"mtime":1527958497000},{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"babel-runtime/regenerator"},{"name":"babel-runtime/helpers/asyncToGenerator"},{"name":"@tensorflow/tfjs","loc":{"line":1,"column":20}},{"name":"./modules/pm-utils/utils","loc":{"line":3,"column":20}},{"name":"./modules/pm-controllers/webcamController","loc":{"line":4,"column":33}},{"name":"./modules/pm-controllers/datasetController","loc":{"line":5,"column":34}}],"generated":{"js":"'use strict';\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _this2 = undefined;\n\nvar loadMobilenet = function () {\n  var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {\n    var mobilenet, layer;\n    return _regenerator2.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return tf.loadModel('https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_0.25_224/model.json');\n\n          case 2:\n            mobilenet = _context.sent;\n\n\n            /* Return a model that outputs an internal activation. */\n            layer = mobilenet.getLayer('conv_pw_13_relu');\n            return _context.abrupt('return', tf.model({ inputs: mobilenet.inputs, outputs: layer.output }));\n\n          case 5:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function loadMobilenet() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/*\n* When the UI buttons are pressed, read a frame from the webcam and associate\n* it with the class label given by the button. up, down, left, right are\n* labels 0, 1, 2, 3 respectively.\n*/\n\n\nvar train = function () {\n  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {\n    var _this = this;\n\n    var optimizer, batchSize;\n    return _regenerator2.default.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(datasetController.xs == null)) {\n              _context3.next = 2;\n              break;\n            }\n\n            throw new Error('Add some examples before training!');\n\n          case 2:\n\n            /*\n            * Creates a 2-layer fully connected model. By creating a separate model,\n            * rather than adding layers to the mobilenet model, we \"freeze\" the weights\n            * of the mobilenet model, and only train weights from the new model.\n            */\n            model = tf.sequential({\n              layers: [tf.layers.flatten({ inputShape: [7, 7, 256] }),\n\n              /* Layer 1 */\n              tf.layers.dense({\n                units: ui.getDenseUnits(),\n                activation: 'relu',\n                kernelInitializer: 'varianceScaling',\n                useBias: true\n              }),\n\n              /*\n              * Layer 2. The number of units of the last layer should correspond\n              * to the number of classes we want to predict.\n              */\n              tf.layers.dense({\n                units: NUM_CLASSES,\n                kernelInitializer: 'varianceScaling',\n                useBias: false,\n                activation: 'softmax'\n              })]\n            });\n\n            optimizer = tf.train.adam(ui.getLearningRate());\n\n\n            model.compile({ optimizer: optimizer, loss: 'categoricalCrossentropy' });\n\n            batchSize = Math.floor(datasetController.xs.shape[0] * ui.getBatchSizeFraction());\n\n            if (batchSize > 0) {\n              _context3.next = 8;\n              break;\n            }\n\n            throw new Error('Batch size is 0 or NaN. Please choose a non-zero fraction.');\n\n          case 8:\n\n            model.fit(datasetController.xs, datasetController.ys, {\n              batchSize: batchSize,\n              epochs: ui.getEpochs(),\n              callbacks: {\n                onBatchEnd: function () {\n                  var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(batch, logs) {\n                    return _regenerator2.default.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            ui.trainStatus('Loss: ' + logs.loss.toFixed(5));\n                            _context2.next = 3;\n                            return tf.nextFrame();\n\n                          case 3:\n                          case 'end':\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, _this);\n                  }));\n\n                  function onBatchEnd(_x, _x2) {\n                    return _ref3.apply(this, arguments);\n                  }\n\n                  return onBatchEnd;\n                }()\n              }\n            });\n\n          case 9:\n          case 'end':\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this);\n  }));\n\n  return function train() {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar predict = function () {\n  var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {\n    var predictedClass, classId;\n    return _regenerator2.default.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            ui.isPredicting();\n\n          case 1:\n            if (!isPredicting) {\n              _context4.next = 12;\n              break;\n            }\n\n            predictedClass = tf.tidy(function () {\n              var img = webcam.capture();\n              var activation = mobilenet.predict(img);\n              var predictions = model.predict(activation);\n\n              return predictions.as1D().argMax();\n            });\n            _context4.next = 5;\n            return predictedClass.data();\n\n          case 5:\n            classId = _context4.sent[0];\n\n\n            predictedClass.dispose();\n            ui.predictClass(classId);\n\n            _context4.next = 10;\n            return tf.nextFrame();\n\n          case 10:\n            _context4.next = 1;\n            break;\n\n          case 12:\n\n            ui.donePredicting();\n\n          case 13:\n          case 'end':\n            return _context4.stop();\n        }\n      }\n    }, _callee4, this);\n  }));\n\n  return function predict() {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar init = function () {\n  var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {\n    return _regenerator2.default.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return webcam.setup();\n\n          case 2:\n            _context6.next = 4;\n            return loadMobilenet();\n\n          case 4:\n            mobilenet = _context6.sent;\n\n\n            /*\n            * Warm up the model. This uploads weights to the GPU and compiles the WebGL\n            * programs so the first time we collect data from the webcam it will be\n            * quick.\n            */\n            tf.tidy(function () {\n              return mobilenet.predict(webcam.capture());\n            });\n\n            ui.init();\n\n          case 7:\n          case 'end':\n            return _context6.stop();\n        }\n      }\n    }, _callee6, this);\n  }));\n\n  return function init() {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nvar _tfjs = require('@tensorflow/tfjs');\n\nvar tf = _interopRequireWildcard(_tfjs);\n\nvar _utils = require('./modules/pm-utils/utils');\n\nvar ui = _interopRequireWildcard(_utils);\n\nvar _webcamController = require('./modules/pm-controllers/webcamController');\n\nvar _datasetController = require('./modules/pm-controllers/datasetController');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* The number of classes that will be predicted is 4 for up, down, left, and right. */\nvar NUM_CLASSES = 4;\n\nvar webcam = new _webcamController.WebcamController(document.getElementById('webcam'));\nvar datasetController = new _datasetController.DatasetController(NUM_CLASSES);\n\nvar mobilenet = void 0;\nvar model = void 0;\n\nui.setExampleHandler(function (label) {\n  tf.tidy(function () {\n    var img = webcam.capture();\n\n    datasetController.addExample(mobilenet.predict(img), label);\n    ui.drawThumb(img, label);\n  });\n});\n\nvar isPredicting = false;\n\ndocument.getElementById('train').addEventListener('click', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {\n  return _regenerator2.default.wrap(function _callee5$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          ui.trainStatus('Training...');\n          _context5.next = 3;\n          return tf.nextFrame();\n\n        case 3:\n          _context5.next = 5;\n          return tf.nextFrame();\n\n        case 5:\n\n          isPredicting = false;\n          train();\n\n        case 7:\n        case 'end':\n          return _context5.stop();\n      }\n    }\n  }, _callee5, _this2);\n})));\n\ndocument.getElementById('predict').addEventListener('click', function () {\n  ui.startPacman();\n  isPredicting = true;\n  predict();\n});\n\ninit();"},"hash":"ae8d1cf563c8617a696007927a827ea5","cacheData":{"env":{}}}