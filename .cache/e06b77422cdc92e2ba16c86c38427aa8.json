{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-layers/package.json","includedInParent":true,"mtime":1528724212618},{"name":"@tensorflow/tfjs-core","loc":{"line":1,"column":21}},{"name":"./backend/tfjs_backend","loc":{"line":2,"column":29}},{"name":"./common","loc":{"line":3,"column":57}},{"name":"./errors","loc":{"line":4,"column":36}},{"name":"./types","loc":{"line":5,"column":38}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.LayerVariable = undefined;\nexports.variable = variable;\nexports.zerosVariable = zerosVariable;\nexports.zerosLike = zerosLike;\nexports.onesVariable = onesVariable;\nexports.onesLike = onesLike;\nexports.eyeVariable = eyeVariable;\nexports.randomUniformVariable = randomUniformVariable;\nexports.truncatedNormalVariable = truncatedNormalVariable;\nexports.randomNormalVariable = randomNormalVariable;\nexports.update = update;\nexports.updateAdd = updateAdd;\nexports.updateSub = updateSub;\nexports.batchGetValue = batchGetValue;\nexports.batchSetValue = batchSetValue;\n\nvar _tfjsCore = require('@tensorflow/tfjs-core');\n\nvar tfc = _interopRequireWildcard(_tfjsCore);\n\nvar _tfjs_backend = require('./backend/tfjs_backend');\n\nvar _common = require('./common');\n\nvar _errors = require('./errors');\n\nvar _types = require('./types');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar DEFAULT_VARIABLE_NAME_PREFIX = 'Variable';\nvar LayerVariable = function () {\n    function LayerVariable(val, dtype, name, trainable, constraint) {\n        if (dtype === void 0) {\n            dtype = 'float32';\n        }\n        if (name === void 0) {\n            name = DEFAULT_VARIABLE_NAME_PREFIX;\n        }\n        if (trainable === void 0) {\n            trainable = true;\n        }\n        if (constraint === void 0) {\n            constraint = null;\n        }\n        this.dtype = dtype == null ? 'float32' : dtype;\n        this.shape = val.shape;\n        this.id = (0, _types.getNextUniqueTensorId)();\n        name = name == null ? DEFAULT_VARIABLE_NAME_PREFIX : name;\n        this.originalName = (0, _common.getScopedTensorName)(name);\n        this.name = (0, _common.getUniqueTensorName)(this.originalName);\n        this.trainable = trainable;\n        this.constraint = constraint;\n        this.val = tfc.variable(val, this.trainable, this.name, this.dtype);\n    }\n    LayerVariable.prototype.read = function () {\n        return this.val;\n    };\n    LayerVariable.prototype.write = function (newVal) {\n        checkShapesMatch(this.val, newVal);\n        this.val.assign(newVal);\n        if (this.constraint != null) {\n            this.val.assign(this.constraint.apply(this.val));\n        }\n        return this;\n    };\n    return LayerVariable;\n}();\nexports.LayerVariable = LayerVariable;\n\nfunction checkShapesMatch(x, y) {\n    if (x.shape.toString() !== y.shape.toString()) {\n        throw new Error('Shape mismatch: ' + JSON.stringify(x.shape) + ' vs. ' + JSON.stringify(y.shape));\n    }\n}\nfunction variable(x, dtype, name, constraint) {\n    return new LayerVariable(x, dtype, name, true, constraint);\n}\nfunction zerosVariable(shape, dtype, name) {\n    return new LayerVariable(tfc.zeros(shape), dtype, name);\n}\nfunction zerosLike(x, dtype, name) {\n    return new LayerVariable(tfc.zerosLike(x), dtype, name);\n}\nfunction onesVariable(shape, dtype, name) {\n    var allocated = tfc.ones(shape);\n    return new LayerVariable(allocated, dtype, name);\n}\nfunction onesLike(x, dtype, name) {\n    var allocated = tfc.onesLike(x);\n    return new LayerVariable(allocated, dtype, name);\n}\nfunction eyeVariable(size, dtype, name) {\n    return new LayerVariable(tfc.eye(size), dtype, name);\n}\nfunction randomUniformVariable(shape, minval, maxval, dtype, seed, name) {\n    if (name === void 0) {\n        name = 'randomUniform';\n    }\n    return new LayerVariable(tfc.randomUniform(shape, minval, maxval, dtype), dtype, name);\n}\nfunction truncatedNormalVariable(shape, mean, stddev, dtype, seed, name) {\n    if (mean === void 0) {\n        mean = 0.0;\n    }\n    if (stddev === void 0) {\n        stddev = 1.0;\n    }\n    if (name === void 0) {\n        name = 'truncatedNormal';\n    }\n    if (dtype === 'bool') {\n        throw new _errors.NotImplementedError(\"randomNormal does not support dType bool.\");\n    }\n    return new LayerVariable(tfc.truncatedNormal(shape, mean, stddev, dtype, seed), dtype, name);\n}\nfunction randomNormalVariable(shape, mean, stddev, dtype, seed, name) {\n    if (mean === void 0) {\n        mean = 0.0;\n    }\n    if (stddev === void 0) {\n        stddev = 1.0;\n    }\n    if (name === void 0) {\n        name = 'randomNormal';\n    }\n    if (dtype === 'bool') {\n        throw new _errors.NotImplementedError(\"randomNormalVariable does not support dType bool.\");\n    }\n    return new LayerVariable((0, _tfjs_backend.randomNormal)(shape, mean, stddev, dtype, seed), dtype, name);\n}\nfunction update(x, xNew) {\n    return x.write(xNew);\n}\nfunction updateAdd(x, increment) {\n    return x.write(tfc.add(x.read(), increment));\n}\nfunction updateSub(x, decrement) {\n    return x.write(tfc.sub(x.read(), decrement));\n}\nfunction batchGetValue(xs) {\n    return xs.map(function (x) {\n        return x.read();\n    });\n}\nfunction batchSetValue(variablesAndValues) {\n    variablesAndValues.map(function (variableAndValue) {\n        var variable = variableAndValue[0];\n        variable.write(variableAndValue[1]);\n    });\n}\n//# sourceMappingURL=variables.js.map"},"hash":"05e39133830526777565626677ac2ace","cacheData":{"env":{}}}