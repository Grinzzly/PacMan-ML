{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-layers/package.json","includedInParent":true,"mtime":1528724212618},{"name":"@tensorflow/tfjs-core","loc":{"line":12,"column":36}},{"name":"../activations","loc":{"line":13,"column":51}},{"name":"../backend/common","loc":{"line":14,"column":32}},{"name":"../backend/tfjs_backend","loc":{"line":15,"column":19}},{"name":"../common","loc":{"line":16,"column":50}},{"name":"../constraints","loc":{"line":17,"column":51}},{"name":"../engine/topology","loc":{"line":18,"column":33}},{"name":"../errors","loc":{"line":19,"column":48}},{"name":"../initializers","loc":{"line":20,"column":53}},{"name":"../regularizers","loc":{"line":21,"column":53}},{"name":"../utils/conv_utils","loc":{"line":22,"column":63}},{"name":"../utils/generic_utils","loc":{"line":23,"column":31}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.UpSampling2D = exports.Cropping2D = exports.Conv1D = exports.SeparableConv2D = exports.SeparableConv = exports.Conv2DTranspose = exports.Conv2D = exports.Conv = undefined;\nexports.preprocessConv2DInput = preprocessConv2DInput;\nexports.conv1dWithBias = conv1dWithBias;\nexports.conv1d = conv1d;\nexports.conv2d = conv2d;\nexports.conv2dWithBias = conv2dWithBias;\n\nvar _tfjsCore = require('@tensorflow/tfjs-core');\n\nvar tfc = _interopRequireWildcard(_tfjsCore);\n\nvar _activations = require('../activations');\n\nvar _common = require('../backend/common');\n\nvar _tfjs_backend = require('../backend/tfjs_backend');\n\nvar K = _interopRequireWildcard(_tfjs_backend);\n\nvar _common2 = require('../common');\n\nvar _constraints = require('../constraints');\n\nvar _topology = require('../engine/topology');\n\nvar _errors = require('../errors');\n\nvar _initializers = require('../initializers');\n\nvar _regularizers = require('../regularizers');\n\nvar _conv_utils = require('../utils/conv_utils');\n\nvar _generic_utils = require('../utils/generic_utils');\n\nvar generic_utils = _interopRequireWildcard(_generic_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nfunction preprocessConv2DInput(x, dataFormat) {\n    return (0, _tfjsCore.tidy)(function () {\n        (0, _common2.checkDataFormat)(dataFormat);\n        if (dataFormat === 'channelsFirst') {\n            return tfc.transpose(x, [0, 2, 3, 1]);\n        } else {\n            return x;\n        }\n    });\n}\nfunction conv1dWithBias(x, kernel, bias, strides, padding, dataFormat, dilationRate) {\n    if (strides === void 0) {\n        strides = 1;\n    }\n    if (padding === void 0) {\n        padding = 'valid';\n    }\n    if (dilationRate === void 0) {\n        dilationRate = 1;\n    }\n    return (0, _tfjsCore.tidy)(function () {\n        if (dataFormat == null) {\n            dataFormat = (0, _common.imageDataFormat)();\n        }\n        (0, _common2.checkDataFormat)(dataFormat);\n        if (x.shape.length !== 3) {\n            throw new _errors.ValueError(\"The input of a conv1dWithBias operation should be 3, but is \" + (x.shape.length + \" instead.\"));\n        }\n        if (kernel.shape.length !== 3) {\n            throw new _errors.ValueError(\"The kernel for a conv1dWithBias operation should be 3, but is \" + (kernel.shape.length + \" instead\"));\n        }\n        if (bias != null && bias.shape.length !== 1) {\n            throw new _errors.ValueError(\"The bias for a conv1dWithBias operation should be 1, but is \" + (kernel.shape.length + \" instead\"));\n        }\n        if (dataFormat === 'channelsFirst') {\n            x = tfc.transpose(x, [0, 2, 1]);\n        }\n        if (padding === 'causal') {\n            throw new _errors.NotImplementedError('The support for CAUSAL padding mode in conv1dWithBias is not ' + 'implemented yet.');\n        }\n        var y = tfc.conv1d(x, kernel, strides, padding === 'same' ? 'same' : 'valid', 'NWC', dilationRate);\n        if (bias != null) {\n            y = K.biasAdd(y, bias);\n        }\n        return y;\n    });\n}\nfunction conv1d(x, kernel, strides, padding, dataFormat, dilationRate) {\n    if (strides === void 0) {\n        strides = 1;\n    }\n    if (padding === void 0) {\n        padding = 'valid';\n    }\n    if (dilationRate === void 0) {\n        dilationRate = 1;\n    }\n    return (0, _tfjsCore.tidy)(function () {\n        (0, _common2.checkDataFormat)(dataFormat);\n        return conv1dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);\n    });\n}\nfunction conv2d(x, kernel, strides, padding, dataFormat, dilationRate) {\n    if (strides === void 0) {\n        strides = [1, 1];\n    }\n    if (padding === void 0) {\n        padding = 'valid';\n    }\n    return (0, _tfjsCore.tidy)(function () {\n        (0, _common2.checkDataFormat)(dataFormat);\n        return conv2dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);\n    });\n}\nfunction conv2dWithBias(x, kernel, bias, strides, padding, dataFormat, dilationRate) {\n    if (strides === void 0) {\n        strides = [1, 1];\n    }\n    if (padding === void 0) {\n        padding = 'valid';\n    }\n    return (0, _tfjsCore.tidy)(function () {\n        if (dataFormat == null) {\n            dataFormat = (0, _common.imageDataFormat)();\n        }\n        (0, _common2.checkDataFormat)(dataFormat);\n        if (x.rank !== 3 && x.rank !== 4) {\n            throw new _errors.ValueError(\"conv2dWithBias expects input to be of rank 3 or 4, but received \" + (x.rank + \".\"));\n        }\n        if (kernel.rank !== 3 && kernel.rank !== 4) {\n            throw new _errors.ValueError(\"conv2dWithBias expects kernel to be of rank 3 or 4, but received \" + (x.rank + \".\"));\n        }\n        var y = preprocessConv2DInput(x, dataFormat);\n        if (padding === 'causal') {\n            throw new _errors.NotImplementedError('The support for CAUSAL padding mode in conv1dWithBias is not ' + 'implemented yet.');\n        }\n        y = tfc.conv2d(y, kernel, strides, padding === 'same' ? 'same' : 'valid', 'NHWC', dilationRate);\n        if (bias != null) {\n            y = K.biasAdd(y, bias);\n        }\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 3, 1, 2]);\n        }\n        return y;\n    });\n}\nvar Conv = function (_super) {\n    __extends(Conv, _super);\n    function Conv(rank, config) {\n        var _this = _super.call(this, config) || this;\n        _this.kernel = null;\n        _this.bias = null;\n        _this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n        _this.DEFAULT_BIAS_INITIALIZER = 'zeros';\n        _this.rank = rank;\n        if (_this.rank !== 1 && _this.rank !== 2) {\n            throw new _errors.NotImplementedError(\"Convolution layer for rank other than 1 or 2 (\" + _this.rank + \") is \" + \"not implemented yet.\");\n        }\n        _this.filters = config.filters;\n        _this.kernelSize = (0, _conv_utils.normalizeArray)(config.kernelSize, rank, 'kernelSize');\n        _this.strides = (0, _conv_utils.normalizeArray)(config.strides == null ? 1 : config.strides, rank, 'strides');\n        _this.padding = config.padding == null ? 'valid' : config.padding;\n        (0, _common2.checkPaddingMode)(_this.padding);\n        _this.dataFormat = config.dataFormat == null ? 'channelsLast' : config.dataFormat;\n        (0, _common2.checkDataFormat)(_this.dataFormat);\n        _this.dilationRate = config.dilationRate == null ? 1 : config.dilationRate;\n        if (_this.rank === 1 && Array.isArray(_this.dilationRate) && _this.dilationRate.length !== 1) {\n            throw new _errors.ValueError(\"dilationRate must be a number or an array of a single number \" + \"for 1D convolution, but received \" + (\"\" + JSON.stringify(_this.dilationRate)));\n        }\n        if (_this.rank === 2) {\n            if (typeof _this.dilationRate === 'number') {\n                _this.dilationRate = [_this.dilationRate, _this.dilationRate];\n            } else if (_this.dilationRate.length !== 2) {\n                throw new _errors.ValueError(\"dilationRate must be a number or array of two numbers for 2D \" + (\"convolution, but received \" + JSON.stringify(_this.dilationRate)));\n            }\n        }\n        _this.activation = (0, _activations.getActivation)(config.activation);\n        _this.useBias = config.useBias == null ? true : config.useBias;\n        _this.kernelInitializer = (0, _initializers.getInitializer)(config.kernelInitializer || _this.DEFAULT_KERNEL_INITIALIZER);\n        _this.biasInitializer = (0, _initializers.getInitializer)(config.biasInitializer || _this.DEFAULT_BIAS_INITIALIZER);\n        _this.kernelConstraint = (0, _constraints.getConstraint)(config.kernelConstraint);\n        _this.biasConstraint = (0, _constraints.getConstraint)(config.biasConstraint);\n        _this.kernelRegularizer = (0, _regularizers.getRegularizer)(config.kernelRegularizer);\n        _this.biasRegularizer = (0, _regularizers.getRegularizer)(config.biasRegularizer);\n        _this.activityRegularizer = (0, _regularizers.getRegularizer)(config.activityRegularizer);\n        return _this;\n    }\n    Conv.prototype.build = function (inputShape) {\n        inputShape = generic_utils.getExactlyOneShape(inputShape);\n        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;\n        if (inputShape[channelAxis] == null) {\n            throw new _errors.ValueError(\"The channel dimension of the input should be defined. \" + (\"Found \" + inputShape[channelAxis]));\n        }\n        var inputDim = inputShape[channelAxis];\n        var kernelShape = this.kernelSize.concat([inputDim, this.filters]);\n        this.kernel = this.addWeight('kernel', kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        this.inputSpec = [{ ndim: this.rank + 2, axes: (_a = {}, _a[channelAxis] = inputDim, _a) }];\n        this.built = true;\n        var _a;\n    };\n    Conv.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return (0, _tfjsCore.tidy)(function () {\n            inputs = generic_utils.getExactlyOneTensor(inputs);\n            var outputs;\n            var biasValue = _this.bias == null ? null : _this.bias.read();\n            if (_this.rank === 1) {\n                outputs = conv1dWithBias(inputs, _this.kernel.read(), biasValue, _this.strides[0], _this.padding, _this.dataFormat, _this.dilationRate);\n            } else if (_this.rank === 2) {\n                outputs = conv2dWithBias(inputs, _this.kernel.read(), biasValue, _this.strides, _this.padding, _this.dataFormat, _this.dilationRate);\n            } else if (_this.rank === 3) {\n                throw new _errors.NotImplementedError('3D convolution is not implemented yet.');\n            }\n            if (_this.activation != null) {\n                outputs = _this.activation.apply(outputs);\n            }\n            return outputs;\n        });\n    };\n    Conv.prototype.computeOutputShape = function (inputShape) {\n        inputShape = generic_utils.getExactlyOneShape(inputShape);\n        var newSpace = [];\n        var space = this.dataFormat === 'channelsLast' ? inputShape.slice(1, inputShape.length - 1) : inputShape.slice(2);\n        for (var i = 0; i < space.length; ++i) {\n            var newDim = (0, _conv_utils.convOutputLength)(space[i], this.kernelSize[i], this.padding, this.strides[i], typeof this.dilationRate === 'number' ? this.dilationRate : this.dilationRate[i]);\n            newSpace.push(newDim);\n        }\n        var outputShape = [inputShape[0]];\n        if (this.dataFormat === 'channelsLast') {\n            outputShape = outputShape.concat(newSpace);\n            outputShape.push(this.filters);\n        } else {\n            outputShape.push(this.filters);\n            outputShape = outputShape.concat(newSpace);\n        }\n        return outputShape;\n    };\n    Conv.prototype.getConfig = function () {\n        var config = {\n            rank: this.rank,\n            filters: this.filters,\n            kernelSize: this.kernelSize,\n            strides: this.strides,\n            padding: this.padding,\n            dataFormat: this.dataFormat,\n            dilationRate: this.dilationRate,\n            activation: (0, _activations.serializeActivation)(this.activation),\n            useBias: this.useBias,\n            kernelInitializer: (0, _initializers.serializeInitializer)(this.kernelInitializer),\n            biasInitializer: (0, _initializers.serializeInitializer)(this.biasInitializer),\n            kernelRegularizer: (0, _regularizers.serializeRegularizer)(this.kernelRegularizer),\n            biasRegularizer: (0, _regularizers.serializeRegularizer)(this.biasRegularizer),\n            activityRegularizer: (0, _regularizers.serializeRegularizer)(this.activityRegularizer),\n            kernelConstraint: (0, _constraints.serializeConstraint)(this.kernelConstraint),\n            biasConstraint: (0, _constraints.serializeConstraint)(this.biasConstraint)\n        };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    return Conv;\n}(_topology.Layer);\nexports.Conv = Conv;\n\nvar Conv2D = function (_super) {\n    __extends(Conv2D, _super);\n    function Conv2D(config) {\n        return _super.call(this, 2, config) || this;\n    }\n    Conv2D.prototype.getConfig = function () {\n        var config = _super.prototype.getConfig.call(this);\n        delete config['rank'];\n        return config;\n    };\n    Conv2D.className = 'Conv2D';\n    return Conv2D;\n}(Conv);\nexports.Conv2D = Conv2D;\n\n_tfjsCore.serialization.SerializationMap.register(Conv2D);\nvar Conv2DTranspose = function (_super) {\n    __extends(Conv2DTranspose, _super);\n    function Conv2DTranspose(config) {\n        var _this = _super.call(this, config) || this;\n        _this.inputSpec = [new _topology.InputSpec({ ndim: 4 })];\n        if (_this.padding !== 'same' && _this.padding !== 'valid') {\n            throw new _errors.ValueError(\"Conv2DTranspose currently supports only padding modes 'same' \" + (\"and 'valid', but received padding mode \" + _this.padding));\n        }\n        return _this;\n    }\n    Conv2DTranspose.prototype.build = function (inputShape) {\n        inputShape = generic_utils.getExactlyOneShape(inputShape);\n        if (inputShape.length !== 4) {\n            throw new _errors.ValueError('Input should have rank 4; Received input shape: ' + JSON.stringify(inputShape));\n        }\n        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;\n        if (inputShape[channelAxis] == null) {\n            throw new _errors.ValueError('The channel dimension of the inputs should be defined. ' + 'Found `None`.');\n        }\n        var inputDim = inputShape[channelAxis];\n        var kernelShape = this.kernelSize.concat([this.filters, inputDim]);\n        this.kernel = this.addWeight('kernel', kernelShape, 'float32', this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [this.filters], 'float32', this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        this.inputSpec = [new _topology.InputSpec({ ndim: 4, axes: (_a = {}, _a[channelAxis] = inputDim, _a) })];\n        this.built = true;\n        var _a;\n    };\n    Conv2DTranspose.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return tfc.tidy(function () {\n            var input = generic_utils.getExactlyOneTensor(inputs);\n            if (input.shape.length !== 4) {\n                throw new _errors.ValueError(\"Conv2DTranspose.call() expects input tensor to be rank-4, but \" + (\"received a tensor of rank-\" + input.shape.length));\n            }\n            var inputShape = input.shape;\n            var batchSize = inputShape[0];\n            var hAxis;\n            var wAxis;\n            if (_this.dataFormat === 'channelsFirst') {\n                hAxis = 2;\n                wAxis = 3;\n            } else {\n                hAxis = 1;\n                wAxis = 2;\n            }\n            var height = inputShape[hAxis];\n            var width = inputShape[wAxis];\n            var kernelH = _this.kernelSize[0];\n            var kernelW = _this.kernelSize[1];\n            var strideH = _this.strides[0];\n            var strideW = _this.strides[1];\n            var outHeight = (0, _conv_utils.deconvLength)(height, strideH, kernelH, _this.padding);\n            var outWidth = (0, _conv_utils.deconvLength)(width, strideW, kernelW, _this.padding);\n            var outputShape = [batchSize, outHeight, outWidth, _this.filters];\n            if (_this.dataFormat !== 'channelsLast') {\n                input = tfc.transpose(input, [0, 2, 3, 1]);\n            }\n            var outputs = tfc.conv2dTranspose(input, _this.kernel.read(), outputShape, _this.strides, _this.padding);\n            if (_this.dataFormat !== 'channelsLast') {\n                outputs = tfc.transpose(outputs, [0, 3, 1, 2]);\n            }\n            if (_this.bias != null) {\n                outputs = K.biasAdd(outputs, _this.bias.read(), _this.dataFormat);\n            }\n            if (_this.activation != null) {\n                outputs = _this.activation.apply(outputs);\n            }\n            return outputs;\n        });\n    };\n    Conv2DTranspose.prototype.computeOutputShape = function (inputShape) {\n        inputShape = generic_utils.getExactlyOneShape(inputShape);\n        var outputShape = inputShape.slice();\n        var channelAxis;\n        var heightAxis;\n        var widthAxis;\n        if (this.dataFormat === 'channelsFirst') {\n            channelAxis = 1;\n            heightAxis = 2;\n            widthAxis = 3;\n        } else {\n            channelAxis = 3;\n            heightAxis = 1;\n            widthAxis = 2;\n        }\n        var kernelH = this.kernelSize[0];\n        var kernelW = this.kernelSize[1];\n        var strideH = this.strides[0];\n        var strideW = this.strides[1];\n        outputShape[channelAxis] = this.filters;\n        outputShape[heightAxis] = (0, _conv_utils.deconvLength)(outputShape[heightAxis], strideH, kernelH, this.padding);\n        outputShape[widthAxis] = (0, _conv_utils.deconvLength)(outputShape[widthAxis], strideW, kernelW, this.padding);\n        return outputShape;\n    };\n    Conv2DTranspose.prototype.getConfig = function () {\n        var config = _super.prototype.getConfig.call(this);\n        delete config['dilationRate'];\n        return config;\n    };\n    Conv2DTranspose.className = 'Conv2DTranspose';\n    return Conv2DTranspose;\n}(Conv2D);\nexports.Conv2DTranspose = Conv2DTranspose;\n\n_tfjsCore.serialization.SerializationMap.register(Conv2DTranspose);\nvar SeparableConv = function (_super) {\n    __extends(SeparableConv, _super);\n    function SeparableConv(rank, config) {\n        var _this = _super.call(this, rank, config) || this;\n        _this.DEFAULT_DEPTHWISE_INITIALIZER = 'glorotUniform';\n        _this.DEFAULT_POINTWISE_INITIALIZER = 'glorotUniform';\n        _this.depthwiseKernel = null;\n        _this.pointwiseKernel = null;\n        if (config.filters == null) {\n            throw new _errors.ValueError('The `filters` configuration field is required by SeparableConv, ' + 'but is unspecified.');\n        }\n        if (config.kernelInitializer != null || config.kernelRegularizer != null || config.kernelConstraint != null) {\n            throw new _errors.ValueError('Fields kernelInitializer, kernelRegularizer and kernelConstraint ' + 'are invalid for SeparableConv2D. Use depthwiseInitializer, ' + 'depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, ' + 'pointwiseRegularizer and pointwiseConstraint instead.');\n        }\n        if (config.padding != null && config.padding !== 'same' && config.padding !== 'valid') {\n            throw new _errors.ValueError(\"SeparableConv\" + _this.rank + \"D supports only padding modes: \" + (\"'same' and 'valid', but received \" + JSON.stringify(config.padding)));\n        }\n        _this.depthMultiplier = config.depthMultiplier == null ? 1 : config.depthMultiplier;\n        _this.depthwiseInitializer = (0, _initializers.getInitializer)(config.depthwiseInitializer || _this.DEFAULT_DEPTHWISE_INITIALIZER);\n        _this.depthwiseRegularizer = (0, _regularizers.getRegularizer)(config.depthwiseRegularizer);\n        _this.depthwiseConstraint = (0, _constraints.getConstraint)(config.depthwiseConstraint);\n        _this.pointwiseInitializer = (0, _initializers.getInitializer)(config.depthwiseInitializer || _this.DEFAULT_POINTWISE_INITIALIZER);\n        _this.pointwiseRegularizer = (0, _regularizers.getRegularizer)(config.pointwiseRegularizer);\n        _this.pointwiseConstraint = (0, _constraints.getConstraint)(config.pointwiseConstraint);\n        return _this;\n    }\n    SeparableConv.prototype.build = function (inputShape) {\n        inputShape = generic_utils.getExactlyOneShape(inputShape);\n        if (inputShape.length < this.rank + 2) {\n            throw new _errors.ValueError(\"Inputs to SeparableConv\" + this.rank + \"D should have rank \" + (this.rank + 2 + \", but received input shape: \") + (\"\" + JSON.stringify(inputShape)));\n        }\n        var channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;\n        if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {\n            throw new _errors.ValueError(\"The channel dimension of the inputs should be defined, \" + (\"but found \" + JSON.stringify(inputShape[channelAxis])));\n        }\n        var inputDim = inputShape[channelAxis];\n        var depthwiseKernelShape = this.kernelSize.concat([inputDim, this.depthMultiplier]);\n        var pointwiseKernelShape = [];\n        for (var i = 0; i < this.rank; ++i) {\n            pointwiseKernelShape.push(1);\n        }\n        pointwiseKernelShape.push(inputDim * this.depthMultiplier, this.filters);\n        var trainable = true;\n        this.depthwiseKernel = this.addWeight('depthwise_kernel', depthwiseKernelShape, 'float32', this.depthwiseInitializer, this.depthwiseRegularizer, trainable, this.depthwiseConstraint);\n        this.pointwiseKernel = this.addWeight('pointwise_kernel', pointwiseKernelShape, 'float32', this.pointwiseInitializer, this.pointwiseRegularizer, trainable, this.pointwiseConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [this.filters], 'float32', this.biasInitializer, this.biasRegularizer, trainable, this.biasConstraint);\n        } else {\n            this.bias = null;\n        }\n        this.inputSpec = [new _topology.InputSpec({ ndim: this.rank + 2, axes: (_a = {}, _a[channelAxis] = inputDim, _a) })];\n        this.built = true;\n        var _a;\n    };\n    SeparableConv.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return (0, _tfjsCore.tidy)(function () {\n            inputs = generic_utils.getExactlyOneTensor(inputs);\n            var output;\n            if (_this.rank === 1) {\n                throw new _errors.NotImplementedError('1D separable convolution is not implemented yet.');\n            } else if (_this.rank === 2) {\n                if (_this.dataFormat === 'channelsFirst') {\n                    inputs = tfc.transpose(inputs, [0, 2, 3, 1]);\n                }\n                output = tfc.separableConv2d(inputs, _this.depthwiseKernel.read(), _this.pointwiseKernel.read(), _this.strides, _this.padding, _this.dilationRate, 'NHWC');\n            }\n            if (_this.useBias) {\n                output = K.biasAdd(output, _this.bias.read(), _this.dataFormat);\n            }\n            if (_this.activation != null) {\n                output = _this.activation.apply(output);\n            }\n            if (_this.dataFormat === 'channelsFirst') {\n                output = tfc.transpose(output, [0, 3, 1, 2]);\n            }\n            return output;\n        });\n    };\n    SeparableConv.prototype.getConfig = function () {\n        var config = _super.prototype.getConfig.call(this);\n        delete config['rank'];\n        delete config['kernelInitializer'];\n        delete config['kernelRegularizer'];\n        delete config['kernelConstraint'];\n        config['depthwiseInitializer'] = (0, _initializers.serializeInitializer)(this.depthwiseInitializer);\n        config['pointwiseInitializer'] = (0, _initializers.serializeInitializer)(this.pointwiseInitializer);\n        config['depthwiseRegularizer'] = (0, _regularizers.serializeRegularizer)(this.depthwiseRegularizer);\n        config['pointwiseRegularizer'] = (0, _regularizers.serializeRegularizer)(this.pointwiseRegularizer);\n        config['depthwiseConstraint'] = (0, _constraints.serializeConstraint)(this.depthwiseConstraint);\n        config['pointwiseConstraint'] = (0, _constraints.serializeConstraint)(this.pointwiseConstraint);\n        return config;\n    };\n    SeparableConv.className = 'SeparableConv';\n    return SeparableConv;\n}(Conv);\nexports.SeparableConv = SeparableConv;\n\nvar SeparableConv2D = function (_super) {\n    __extends(SeparableConv2D, _super);\n    function SeparableConv2D(config) {\n        return _super.call(this, 2, config) || this;\n    }\n    SeparableConv2D.className = 'SeparableConv2D';\n    return SeparableConv2D;\n}(SeparableConv);\nexports.SeparableConv2D = SeparableConv2D;\n\n_tfjsCore.serialization.SerializationMap.register(SeparableConv2D);\nvar Conv1D = function (_super) {\n    __extends(Conv1D, _super);\n    function Conv1D(config) {\n        var _this = _super.call(this, 1, config) || this;\n        _this.inputSpec = [{ ndim: 3 }];\n        return _this;\n    }\n    Conv1D.prototype.getConfig = function () {\n        var config = _super.prototype.getConfig.call(this);\n        delete config['rank'];\n        delete config['dataFormat'];\n        return config;\n    };\n    Conv1D.className = 'Conv1D';\n    return Conv1D;\n}(Conv);\nexports.Conv1D = Conv1D;\n\n_tfjsCore.serialization.SerializationMap.register(Conv1D);\nvar Cropping2D = function (_super) {\n    __extends(Cropping2D, _super);\n    function Cropping2D(config) {\n        var _this = _super.call(this, config) || this;\n        if (typeof config.cropping === 'number') _this.cropping = [[config.cropping, config.cropping], [config.cropping, config.cropping]];else if (typeof config.cropping[0] === 'number') _this.cropping = [[config.cropping[0], config.cropping[0]], [config.cropping[1], config.cropping[1]]];else _this.cropping = config.cropping;\n        _this.dataFormat = config.dataFormat === undefined ? 'channelsLast' : config.dataFormat;\n        _this.inputSpec = [{ ndim: 4 }];\n        return _this;\n    }\n    Cropping2D.prototype.computeOutputShape = function (inputShape) {\n        if (this.dataFormat === 'channelsFirst') return [inputShape[0], inputShape[1], inputShape[2] - this.cropping[0][0] - this.cropping[0][1], inputShape[2] - this.cropping[1][0] - this.cropping[1][1]];else return [inputShape[0], inputShape[1] - this.cropping[0][0] - this.cropping[0][1], inputShape[2] - this.cropping[1][0] - this.cropping[1][1], inputShape[3]];\n    };\n    Cropping2D.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return (0, _tfjsCore.tidy)(function () {\n            inputs = generic_utils.getExactlyOneTensor(inputs);\n            if (_this.dataFormat === 'channelsLast') {\n                var hSliced = K.sliceAlongAxis(inputs, _this.cropping[0][0], inputs.shape[1] - _this.cropping[0][0] - _this.cropping[0][1], 2);\n                return K.sliceAlongAxis(hSliced, _this.cropping[1][0], inputs.shape[2] - _this.cropping[1][1] - _this.cropping[1][0], 3);\n            } else {\n                var hSliced = K.sliceAlongAxis(inputs, _this.cropping[0][0], inputs.shape[2] - _this.cropping[0][0] - _this.cropping[0][1], 3);\n                return K.sliceAlongAxis(hSliced, _this.cropping[1][0], inputs.shape[3] - _this.cropping[1][1] - _this.cropping[1][0], 4);\n            }\n        });\n    };\n    Cropping2D.prototype.getConfig = function () {\n        var config = { cropping: this.cropping, dataFormat: this.dataFormat };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    Cropping2D.className = 'Cropping2D';\n    return Cropping2D;\n}(_topology.Layer);\nexports.Cropping2D = Cropping2D;\n\n_tfjsCore.serialization.SerializationMap.register(Cropping2D);\nvar UpSampling2D = function (_super) {\n    __extends(UpSampling2D, _super);\n    function UpSampling2D(config) {\n        var _this = _super.call(this, config) || this;\n        _this.DEFAULT_SIZE = [2, 2];\n        _this.inputSpec = [{ ndim: 4 }];\n        _this.size = config.size === undefined ? _this.DEFAULT_SIZE : config.size;\n        _this.dataFormat = config.dataFormat === undefined ? 'channelsLast' : config.dataFormat;\n        return _this;\n    }\n    UpSampling2D.prototype.computeOutputShape = function (inputShape) {\n        if (this.dataFormat === 'channelsFirst') {\n            var height = this.size[0] * inputShape[2];\n            var width = this.size[1] * inputShape[3];\n            return [inputShape[0], inputShape[1], height, width];\n        } else {\n            var height = this.size[0] * inputShape[1];\n            var width = this.size[1] * inputShape[2];\n            return [inputShape[0], height, width, inputShape[3]];\n        }\n    };\n    UpSampling2D.prototype.call = function (inputs, kwargs) {\n        var _this = this;\n        return tfc.tidy(function () {\n            var input = generic_utils.getExactlyOneTensor(inputs);\n            var inputShape = input.shape;\n            if (_this.dataFormat === 'channelsFirst') {\n                input = tfc.transpose(input, [0, 2, 3, 1]);\n                var height = _this.size[0] * inputShape[2];\n                var width = _this.size[1] * inputShape[3];\n                var resized = input.resizeNearestNeighbor([height, width]);\n                return tfc.transpose(resized, [0, 3, 1, 2]);\n            } else {\n                var height = _this.size[0] * inputShape[1];\n                var width = _this.size[1] * inputShape[2];\n                return input.resizeNearestNeighbor([height, width]);\n            }\n        });\n    };\n    UpSampling2D.prototype.getConfig = function () {\n        var config = { size: this.size, dataFormat: this.dataFormat };\n        var baseConfig = _super.prototype.getConfig.call(this);\n        Object.assign(config, baseConfig);\n        return config;\n    };\n    UpSampling2D.className = 'UpSampling2D';\n    return UpSampling2D;\n}(_topology.Layer);\nexports.UpSampling2D = UpSampling2D;\n\n_tfjsCore.serialization.SerializationMap.register(UpSampling2D);\n//# sourceMappingURL=convolutional.js.map"},"hash":"a34b85669861adbd0f4ad3ffe919c4ce","cacheData":{"env":{}}}