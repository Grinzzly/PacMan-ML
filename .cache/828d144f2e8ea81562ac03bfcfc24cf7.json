{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-core/package.json","includedInParent":true,"mtime":1528724212618},{"name":"../doc","loc":{"line":7,"column":20}},{"name":"../environment","loc":{"line":8,"column":20}},{"name":"../util","loc":{"line":9,"column":22}},{"name":"./operation","loc":{"line":10,"column":26}},{"name":"./slice_util","loc":{"line":11,"column":28}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.SliceOps = undefined;\n\nvar _doc = require(\"../doc\");\n\nvar _environment = require(\"../environment\");\n\nvar _util = require(\"../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _operation = require(\"./operation\");\n\nvar _slice_util = require(\"./slice_util\");\n\nvar slice_util = _interopRequireWildcard(_slice_util);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar SliceOps = function () {\n    function SliceOps() {}\n    SliceOps.slice1d = function (x, begin, size) {\n        util.assert(x.rank === 1, \"slice1d expects a rank-1 tensor, but got a rank-\" + x.rank + \" tensor\");\n        return SliceOps.slice(x, [begin], [size]);\n    };\n    SliceOps.slice2d = function (x, begin, size) {\n        util.assert(x.rank === 2, \"slice1d expects a rank-2 tensor, but got a rank-\" + x.rank + \" tensor\");\n        return SliceOps.slice(x, begin, size);\n    };\n    SliceOps.slice3d = function (x, begin, size) {\n        util.assert(x.rank === 3, \"slice1d expects a rank-3 tensor, but got a rank-\" + x.rank + \" tensor\");\n        return SliceOps.slice(x, begin, size);\n    };\n    SliceOps.slice4d = function (x, begin, size) {\n        util.assert(x.rank === 4, \"slice1d expects a rank-4 tensor, but got a rank-\" + x.rank + \" tensor\");\n        return SliceOps.slice(x, begin, size);\n    };\n    SliceOps.slice = function (x, begin, size) {\n        util.assertArgumentsAreTensors({ x: x }, 'slice');\n        if (x.rank === 0) {\n            throw new Error('Slicing scalar is not possible');\n        }\n        var begin_;\n        if (typeof begin === 'number') {\n            begin_ = [begin].concat(new Array(x.rank - 1).fill(0));\n        } else if (begin.length < x.rank) {\n            begin_ = begin.concat(new Array(x.rank - begin.length).fill(0));\n        } else {\n            begin_ = begin;\n        }\n        var size_;\n        if (size == null) {\n            size_ = new Array(x.rank).fill(-1);\n        } else if (typeof size === 'number') {\n            size_ = [size].concat(new Array(x.rank - 1).fill(-1));\n        } else if (size.length < x.rank) {\n            size_ = size.concat(new Array(x.rank - size.length).fill(-1));\n        } else {\n            size_ = size;\n        }\n        size_ = size_.map(function (d, i) {\n            if (d >= 0) {\n                return d;\n            } else {\n                util.assert(d === -1, 'Bad value in size');\n                return x.shape[i] - begin_[i];\n            }\n        });\n        slice_util.assertParamsValid(x, begin_, size_);\n        var inputShape = x.shape;\n        var grad = function (dy) {\n            var paddings = [];\n            for (var i = 0; i < dy.rank; i++) {\n                paddings.push([begin_[i], inputShape[i] - begin_[i] - size_[i]]);\n            }\n            return { x: function () {\n                    return dy.pad(paddings);\n                } };\n        };\n        return _environment.ENV.engine.runKernel(function (backend) {\n            return backend.slice(x, begin_, size_);\n        }, { x: x }, grad);\n    };\n    __decorate([(0, _doc.doc)({ heading: 'Tensors', subheading: 'Slicing and Joining' }), _operation.operation], SliceOps, \"slice\", null);\n    return SliceOps;\n}();\nexports.SliceOps = SliceOps;\n//# sourceMappingURL=slice.js.map"},"hash":"6c1ed0c4d1130b1f563d7d01520bbac1","cacheData":{"env":{}}}