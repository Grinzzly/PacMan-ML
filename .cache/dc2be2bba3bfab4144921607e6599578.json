{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"/home/szamulko/Desktop/Projects/PacMan/node_modules/@tensorflow/tfjs-layers/package.json","includedInParent":true,"mtime":1528724212618},{"name":"@tensorflow/tfjs-core","loc":{"line":52,"column":39}},{"name":"./backend/tfjs_backend","loc":{"line":53,"column":19}},{"name":"./engine/topology","loc":{"line":54,"column":45}},{"name":"./engine/training","loc":{"line":55,"column":22}},{"name":"./errors","loc":{"line":56,"column":41}},{"name":"./layers/serialization","loc":{"line":57,"column":28}},{"name":"./utils/generic_utils","loc":{"line":58,"column":31}},{"name":"./utils/serialization_utils","loc":{"line":59,"column":36}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Sequential = undefined;\nexports.modelFromJSON = modelFromJSON;\nexports.loadModelInternal = loadModelInternal;\nexports.loadModelFromIOHandler = loadModelFromIOHandler;\n\nvar _tfjsCore = require(\"@tensorflow/tfjs-core\");\n\nvar _tfjs_backend = require(\"./backend/tfjs_backend\");\n\nvar K = _interopRequireWildcard(_tfjs_backend);\n\nvar _topology = require(\"./engine/topology\");\n\nvar _training = require(\"./engine/training\");\n\nvar _errors = require(\"./errors\");\n\nvar _serialization = require(\"./layers/serialization\");\n\nvar _generic_utils = require(\"./utils/generic_utils\");\n\nvar generic_utils = _interopRequireWildcard(_generic_utils);\n\nvar _serialization_utils = require(\"./utils/serialization_utils\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : new P(function (resolve) {\n                resolve(result.value);\n            }).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = undefined && undefined.__generator || function (thisArg, body) {\n    var _ = { label: 0, sent: function () {\n            if (t[0] & 1) throw t[1];return t[1];\n        }, trys: [], ops: [] },\n        f,\n        y,\n        t,\n        g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n        return this;\n    }), g;\n    function verb(n) {\n        return function (v) {\n            return step([n, v]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0:case 1:\n                    t = op;break;\n                case 4:\n                    _.label++;return { value: op[1], done: false };\n                case 5:\n                    _.label++;y = op[1];op = [0];continue;\n                case 7:\n                    op = _.ops.pop();_.trys.pop();continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];t = op;break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];_.ops.push(op);break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [6, e];y = 0;\n        } finally {\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nfunction modelFromJSON(modelAndWeightsConfig, customObjects) {\n    return __awaiter(this, void 0, void 0, function () {\n        var modelTopology, tsConfig, model, weightValues, uniqueWeightValues, _i, _a, weight, skipMismatches, isNamedTensorMap;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    modelTopology = modelAndWeightsConfig.modelTopology;\n                    if (modelTopology['model_config'] != null) {\n                        modelTopology = modelTopology['model_config'];\n                    }\n                    tsConfig = (0, _serialization_utils.convertPythonicToTs)(modelTopology);\n                    model = (0, _serialization.deserialize)(tsConfig, customObjects);\n                    if (!(modelAndWeightsConfig.weightsManifest != null)) return [3, 2];\n                    return [4, _tfjsCore.io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(function (weight) {\n                        return weight.originalName;\n                    }))];\n                case 1:\n                    weightValues = _b.sent();\n                    uniqueWeightValues = {};\n                    for (_i = 0, _a = model.weights; _i < _a.length; _i++) {\n                        weight = _a[_i];\n                        uniqueWeightValues[weight.originalName] = weightValues[weight.originalName];\n                    }\n                    skipMismatches = null;\n                    isNamedTensorMap = true;\n                    model.loadWeights(uniqueWeightValues, skipMismatches, isNamedTensorMap);\n                    _b.label = 2;\n                case 2:\n                    return [2, model];\n            }\n        });\n    });\n}\nfunction loadModelInternal(pathOrIOHandler) {\n    return __awaiter(this, void 0, void 0, function () {\n        var handlers;\n        return __generator(this, function (_a) {\n            if (typeof pathOrIOHandler === 'string') {\n                handlers = _tfjsCore.io.getLoadHandlers(pathOrIOHandler);\n                if (handlers.length === 0) {\n                    handlers.push(_tfjsCore.io.browserHTTPRequest(pathOrIOHandler));\n                } else if (handlers.length > 1) {\n                    throw new _errors.ValueError(\"Found more than one (\" + handlers.length + \") load handlers for \" + (\"URL '\" + pathOrIOHandler + \"'\"));\n                }\n                pathOrIOHandler = handlers[0];\n            }\n            return [2, loadModelFromIOHandler(pathOrIOHandler)];\n        });\n    });\n}\nfunction loadModelFromIOHandler(handler, customObjects) {\n    return __awaiter(this, void 0, void 0, function () {\n        var artifacts, modelTopology, model, skipMismatch, isNamedTensorMap;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (handler.load == null) {\n                        throw new _errors.ValueError('Cannot proceed with model loading because the IOHandler provided ' + 'does not have the `load` method implemented.');\n                    }\n                    return [4, handler.load()];\n                case 1:\n                    artifacts = _a.sent();\n                    modelTopology = artifacts.modelTopology;\n                    if (modelTopology['model_config'] != null) {\n                        modelTopology = modelTopology['model_config'];\n                    }\n                    model = (0, _serialization.deserialize)((0, _serialization_utils.convertPythonicToTs)(modelTopology), customObjects);\n                    if (artifacts.weightData != null) {\n                        if (artifacts.weightSpecs == null) {\n                            throw new _errors.ValueError('Model artifacts contains weight data, but not weight specs. ' + 'Therefore loading of weights cannot proceed.');\n                        }\n                        skipMismatch = false;\n                        isNamedTensorMap = true;\n                        model.loadWeights(_tfjsCore.io.decodeWeights(artifacts.weightData, artifacts.weightSpecs), skipMismatch, isNamedTensorMap);\n                    }\n                    return [2, model];\n            }\n        });\n    });\n}\nvar Sequential = function (_super) {\n    __extends(Sequential, _super);\n    function Sequential(config) {\n        var _this = _super.call(this, { inputs: [], outputs: [] }) || this;\n        config = config || {};\n        _this.trainable = true;\n        _this._updatable = true;\n        _this.built = false;\n        _this.name = config.name != null ? config.name : K.getUid('sequential_');\n        if (config.layers != null) {\n            for (var _i = 0, _a = config.layers; _i < _a.length; _i++) {\n                var layer = _a[_i];\n                _this.add(layer);\n            }\n        }\n        return _this;\n    }\n    Sequential_1 = Sequential;\n    Sequential.prototype.add = function (layer) {\n        var isLayerModelInstance = layer instanceof Sequential_1 || layer instanceof _training.Model;\n        var modelLayer;\n        if (isLayerModelInstance) {\n            modelLayer = layer;\n            if (modelLayer.outputs.length !== 1) {\n                throw new _errors.ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n            }\n            if (modelLayer.inputs.length !== 1) {\n                throw new _errors.ValueError('All layers in a Sequential model ' + 'should have a single input tensor. ' + 'For multi-input layers, ' + 'use the functional API.');\n            }\n        }\n        if (this.outputs.length === 0) {\n            if (layer.inboundNodes.length === 0) {\n                if (layer.batchInputShape == null) {\n                    throw new _errors.ValueError('The first layer in a Sequential model must ' + 'get an `inputShape` or `batchInputShape` argument.');\n                }\n                var x = (0, _topology.Input)({\n                    batchShape: layer.batchInputShape,\n                    dtype: layer.dtype,\n                    name: layer.name + '_input'\n                });\n                layer.apply(x);\n            }\n            if (isLayerModelInstance) {\n                this.outputs = modelLayer.outputs;\n                this.inputs = modelLayer.inputs;\n            } else {\n                if (layer.inboundNodes.length !== 1) {\n                    throw new _errors.ValueError('A layer added to a Sequential model must not already be ' + (\"connected somewhere else. Model received layer \" + layer.name + \" \") + (\"which has \" + layer.inboundNodes.length + \" pre-existing inbound \") + 'connections.');\n                }\n                if (layer.inboundNodes[0].outputTensors.length !== 1) {\n                    throw new _errors.ValueError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n                }\n                this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n                this.inputs = (0, _topology.getSourceInputs)(this.outputs[0]);\n            }\n            new _topology.Node({\n                outboundLayer: this,\n                inboundLayers: [],\n                nodeIndices: [],\n                tensorIndices: [],\n                inputTensors: this.inputs,\n                outputTensors: this.outputs,\n                inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n                outputMasks: [null],\n                inputShapes: this.inputs.map(function (x) {\n                    return x.shape;\n                }),\n                outputShapes: this.outputs[0].shape\n            });\n        } else {\n            var outputTensor = layer.apply(this.outputs[0]);\n            if (Array.isArray(outputTensor)) {\n                throw new TypeError('All layers in a Sequential model ' + 'should have a single output tensor. ' + 'For multi-output layers, ' + 'use the functional API.');\n            }\n            this.outputs = [outputTensor];\n            this.inboundNodes[0].outputTensors = this.outputs;\n            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n        }\n        this.layers.push(layer);\n        this.built = false;\n    };\n    Sequential.prototype.pop = function () {\n        if (this.layers.length === 0) {\n            throw new TypeError('There are no layers in the model.');\n        }\n        this.layers.pop();\n        if (this.layers.length === 0) {\n            this.outputs = [];\n            this.inboundNodes = [];\n            this.outboundNodes = [];\n        } else {\n            var lastLayerIndex = this.layers.length - 1;\n            this.layers[lastLayerIndex].outboundNodes = [];\n            this.outputs = [this.layers[lastLayerIndex].output];\n            this.inboundNodes[0].outputTensors = this.outputs;\n            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n        }\n    };\n    Sequential.prototype.call = function (inputs, kwargs) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.call(inputs, kwargs);\n    };\n    Sequential.prototype.build = function (inputShape) {\n        generic_utils.getExactlyOneShape(inputShape);\n        if (this.inputs.length === 0 || this.outputs.length === 0) {\n            throw new TypeError('Sequential model cannot be built: model is empty.' + ' Add some layers first.');\n        }\n        this.model = new _training.Model({\n            inputs: this.inputs,\n            outputs: this.outputs[0],\n            name: this.name + '_model'\n        });\n        this.model.trainable = this.trainable;\n        this.model.updatable = this.updatable;\n        this.supportsMasking = this.model.supportsMasking;\n        this.inputLayers = this.model.inputLayers;\n        this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n        this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n        this.outputLayers = this.model.outputLayers;\n        this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n        this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n        this.nodesByDepth = this.model.nodesByDepth;\n        this.containerNodes = this.model.containerNodes;\n        this.outputNames = this.model.outputNames;\n        this.inputNames = this.model.inputNames;\n        this.built = true;\n    };\n    Sequential.prototype.setWeights = function (weights) {\n        if (this.model == null) {\n            this.build();\n        }\n        this.model.setWeights(weights);\n    };\n    Object.defineProperty(Sequential.prototype, \"updatable\", {\n        get: function () {\n            return this._updatable;\n        },\n        set: function (value) {\n            if (this.built) {\n                this.model.updatable = value;\n            }\n            this._updatable = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Sequential.prototype.evaluate = function (x, y, config) {\n        if (config === void 0) {\n            config = {};\n        }\n        if (!this.built) {\n            throw new _errors.RuntimeError('The model needs to be compiled before being used.');\n        }\n        return this.model.evaluate(x, y, config);\n    };\n    Sequential.prototype.predict = function (x, config) {\n        if (config === void 0) {\n            config = {};\n        }\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.predict(x, config);\n    };\n    Sequential.prototype.predictOnBatch = function (x) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.predictOnBatch(x);\n    };\n    Sequential.prototype.compile = function (config) {\n        this.build();\n        this.model.compile(config);\n        this.optimizer = this.model.optimizer;\n        this.loss = this.model.loss;\n        this.metrics = this.model.metrics;\n        this.metricsTensors = this.model.metricsTensors;\n        this.metricsNames = this.model.metricsNames;\n    };\n    Sequential.prototype.fit = function (x, y, config) {\n        if (config === void 0) {\n            config = {};\n        }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!this.built) {\n                    throw new _errors.RuntimeError('The model needs to be compiled before ' + 'being used.');\n                }\n                return [2, this.model.fit(x, y, config)];\n            });\n        });\n    };\n    Sequential.fromConfig = function (cls, config) {\n        var model = new cls({});\n        if (!(model instanceof Sequential_1)) {\n            throw new _errors.ValueError(\"Sequential.fromConfig called on non-Sequential input: \" + model);\n        }\n        if (!(config instanceof Array)) {\n            throw new _errors.ValueError(\"Sequential.fromConfig called without an array of configs\");\n        }\n        if (!(config[0].className != null) || config[0]['className'] === 'Merge') {\n            throw new _errors.ValueError('Legacy serialization format not supported yet.');\n        }\n        for (var _i = 0, _a = config; _i < _a.length; _i++) {\n            var conf = _a[_i];\n            var layer = (0, _serialization.deserialize)(conf);\n            model.add(layer);\n        }\n        return model;\n    };\n    Sequential.prototype.getConfig = function () {\n        var config = [];\n        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {\n            var layer = _a[_i];\n            config.push({\n                className: layer.getClassName(),\n                config: layer.getConfig()\n            });\n        }\n        return config;\n    };\n    Sequential.className = 'Sequential';\n    __decorate([(0, _tfjsCore.doc)({ heading: 'Models', subheading: 'Classes' })], Sequential.prototype, \"add\", null);\n    __decorate([(0, _tfjsCore.doc)({ heading: 'Models', subheading: 'Classes', configParamIndices: [2] })], Sequential.prototype, \"evaluate\", null);\n    __decorate([(0, _tfjsCore.doc)({ heading: 'Models', subheading: 'Classes', configParamIndices: [1] })], Sequential.prototype, \"predict\", null);\n    __decorate([(0, _tfjsCore.doc)({ heading: 'Models', subheading: 'Classes', configParamIndices: [2] })], Sequential.prototype, \"fit\", null);\n    Sequential = Sequential_1 = __decorate([(0, _tfjsCore.doc)({ heading: 'Models', subheading: 'Classes' })], Sequential);\n    return Sequential;\n    var Sequential_1;\n}(_training.Model);\nexports.Sequential = Sequential;\n\n_tfjsCore.serialization.SerializationMap.register(Sequential);\n//# sourceMappingURL=models.js.map"},"hash":"2303366f43902414aa901889c84b7877","cacheData":{"env":{}}}