{"dependencies":[{"name":"/home/szamulko/Desktop/Projects/PacMan/.babelrc","includedInParent":true,"mtime":1527958497000},{"name":"/home/szamulko/Desktop/Projects/PacMan/package.json","includedInParent":true,"mtime":1528724217926},{"name":"babel-runtime/regenerator"},{"name":"babel-runtime/core-js/promise"},{"name":"babel-runtime/helpers/asyncToGenerator"},{"name":"babel-runtime/helpers/classCallCheck"},{"name":"babel-runtime/helpers/createClass"},{"name":"@tensorflow/tfjs","loc":{"line":1,"column":20}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebcamController = undefined;\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _tfjs = require('@tensorflow/tfjs');\n\nvar tf = _interopRequireWildcard(_tfjs);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar WebcamController = exports.WebcamController = function () {\n  /** @param {HTMLVideoElement} webcam. */\n  function WebcamController(webcamElement) {\n    (0, _classCallCheck3.default)(this, WebcamController);\n\n    this.webcamElement = webcamElement;\n  }\n\n  /**\n   * Captures a frame from the webcam and normalizes it between -1 and 1.\n   * Returns a batched image (1-element batch) of shape [1, w, h, c].\n   */\n\n\n  (0, _createClass3.default)(WebcamController, [{\n    key: 'capture',\n    value: function capture() {\n      var _this = this;\n\n      return tf.tidy(function () {\n        var webcamImage = tf.fromPixels(_this.webcamElement);\n        var croppedImage = _this.cropImage(webcamImage);\n        var batchedImage = croppedImage.expandDims(0);\n\n        /* Normalize the image between -1 and 1. */\n        return batchedImage.toFloat().div(tf.scalar(127)).sub(tf.scalar(1));\n      });\n    }\n\n    /** @param {Tensor4D} img. */\n\n  }, {\n    key: 'cropImage',\n    value: function cropImage(img) {\n      var size = Math.min(img.shape[0], img.shape[1]);\n      var centerHeight = img.shape[0] / 2;\n      var beginHeight = centerHeight - size / 2;\n      var centerWidth = img.shape[1] / 2;\n      var beginWidth = centerWidth - size / 2;\n\n      return img.slice([beginHeight, beginWidth, 0], [size, size, 3]);\n    }\n\n    /**\n     * Adjusts the video size to make a centered square crop without\n     * including whitespace.\n     * @param {number} width.\n     * @param {number} height.\n     */\n\n  }, {\n    key: 'adjustVideoSize',\n    value: function adjustVideoSize(width, height) {\n      var aspectRatio = width / height;\n      if (width >= height) {\n        this.webcamElement.width = aspectRatio * this.webcamElement.height;\n      } else if (width < height) {\n        this.webcamElement.height = this.webcamElement.width / aspectRatio;\n      }\n    }\n  }, {\n    key: 'setup',\n    value: function () {\n      var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {\n        var _this2 = this;\n\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt('return', new _promise2.default(function (resolve, reject) {\n                  var navigatorAny = navigator;\n                  navigator.getUserMedia = navigator.getUserMedia || navigatorAny.webkitGetUserMedia || navigatorAny.mozGetUserMedia || navigatorAny.msGetUserMedia;\n\n                  if (navigator.getUserMedia) {\n                    navigator.getUserMedia({ video: true }, function (stream) {\n                      _this2.webcamElement.srcObject = stream;\n                      _this2.webcamElement.addEventListener('loadeddata', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {\n                        return _regenerator2.default.wrap(function _callee$(_context) {\n                          while (1) {\n                            switch (_context.prev = _context.next) {\n                              case 0:\n                                _this2.adjustVideoSize(_this2.webcamElement.videoWidth, _this2.webcamElement.videoHeight);\n\n                                resolve();\n\n                              case 2:\n                              case 'end':\n                                return _context.stop();\n                            }\n                          }\n                        }, _callee, _this2);\n                      })), false);\n                    }, function (error) {\n                      console.debug('Houston we have a problem!', error);\n                      document.querySelector('#no-webcam').style.display = 'block';\n                    });\n                  } else {\n                    reject();\n                  }\n                }));\n\n              case 1:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function setup() {\n        return _ref.apply(this, arguments);\n      }\n\n      return setup;\n    }()\n  }]);\n  return WebcamController;\n}();"},"hash":"127992aa09ad21a3a91428cd0bf30561","cacheData":{"env":{}}}